#!/usr/bin/env python
"""
Enhanced runner for MCP server with AnyIO support.

This script provides a more reliable way to start the MCP server
with AnyIO support and proper error handling.
"""

import os
import sys
import time
import logging
import argparse
import subprocess
import signal
import uvicorn
from fastapi import FastAPI, APIRouter

# Configure root logger
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)

def create_app(debug_mode=True, 
              isolation_mode=True, 
              skip_daemon=True, 
              persistence_path=None,
              api_prefix="/api/v0"):
    """Create the FastAPI app with configured MCP server."""
    
    # Import the MCP server with AnyIO support
    try:
        from ipfs_kit_py.mcp.server_anyio import MCPServer
    except ImportError as e:
        logger.error(f"Failed to import MCPServer AnyIO: {e}")
        raise
        
    # Create FastAPI app
    app = FastAPI(
        title="IPFS MCP Server (AnyIO)",
        description="Model-Controller-Persistence Server for IPFS Kit with AnyIO support",
        version="0.1.0"
    )
    
    # Use default persistence path if not specified
    if persistence_path is None:
        persistence_path = os.path.expanduser("~/.ipfs_kit/mcp_anyio")
        
    # Create MCP server with specified settings
    try:
        logger.info(f"Creating MCPServer with debug={debug_mode}, isolation={isolation_mode}, skip_daemon={skip_daemon}")
        logger.info(f"Using persistence path: {persistence_path}")
        logger.info(f"API prefix: {api_prefix}")
        
        mcp_server = MCPServer(
            debug_mode=debug_mode,
            isolation_mode=isolation_mode,
            persistence_path=persistence_path,
            skip_daemon=skip_daemon,
            log_level="DEBUG" if debug_mode else "INFO"
        )
    except Exception as e:
        logger.error(f"Failed to create MCPServer: {e}")
        raise
        
    # Register MCP server with app
    try:
        mcp_server.register_with_app(app, prefix=api_prefix)
    except Exception as e:
        logger.error(f"Failed to register MCPServer with app: {e}")
        raise
        
    # Add a root endpoint with server information
    @app.get("/")
    async def root():
        """Root endpoint with server information."""
        # Get daemon status information if available
        daemon_info = {}
        if hasattr(mcp_server.ipfs_kit, 'check_daemon_status'):
            try:
                status = mcp_server.ipfs_kit.check_daemon_status()
                daemon_info = status.get("daemons", {})
            except Exception as e:
                logger.error(f"Error getting daemon status: {e}")
                daemon_info = {"error": str(e)}
                
        # Get server version information if available
        version_info = {}
        if hasattr(mcp_server, 'get_version_info'):
            try:
                version_info = mcp_server.get_version_info()
            except Exception as e:
                logger.error(f"Error getting version info: {e}")
                version_info = {"error": str(e)}
                
        # List all registered controllers
        controllers = list(mcp_server.controllers.keys())
        
        # Server configuration
        config = {
            "debug_mode": debug_mode,
            "isolation_mode": isolation_mode,
            "skip_daemon": skip_daemon,
            "persistence_path": persistence_path,
            "api_prefix": api_prefix
        }
        
        # List available endpoints
        endpoints = {
            "health_check": f"{api_prefix}/health",
            "debug_state": f"{api_prefix}/debug" if debug_mode else "Disabled (debug mode required)",
            "daemon_management": {
                "daemon_status": f"{api_prefix}/daemon/status",
                "start_daemon": f"{api_prefix}/daemon/start/{{daemon_type}}",
                "stop_daemon": f"{api_prefix}/daemon/stop/{{daemon_type}}",
                "start_monitor": f"{api_prefix}/daemon/monitor/start",
                "stop_monitor": f"{api_prefix}/daemon/monitor/stop"
            },
            "ipfs": {
                "version": f"{api_prefix}/ipfs/version",
                "id": f"{api_prefix}/ipfs/id",
                "cat": f"{api_prefix}/ipfs/cat/{{cid}}",
                "pin_ls": f"{api_prefix}/ipfs/pin/ls"
            },
            "webrtc": {
                "check": f"{api_prefix}/webrtc/check",
                "status": f"{api_prefix}/webrtc/status"
            }
        }
        
        return {
            "message": "MCP Server (AnyIO) is running", 
            "config": config,
            "controllers": controllers,
            "daemon_status": daemon_info,
            "version_info": version_info,
            "endpoints": endpoints,
            "documentation": "/docs"
        }
        
    # Add shutdown event handler
    @app.on_event("shutdown")
    async def shutdown_event():
        """Handle FastAPI shutdown event."""
        logger.info("FastAPI shutdown event received, cleaning up MCP server")
        if hasattr(mcp_server, 'shutdown'):
            try:
                # Call shutdown method if available
                result = mcp_server.shutdown()
                logger.info(f"MCP server shutdown completed: {result}")
            except Exception as e:
                logger.error(f"Error during MCP server shutdown: {e}")
        
    return app, mcp_server

def main():
    """Main entrypoint for the MCP server AnyIO runner."""
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="Run MCP server with AnyIO support")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("--isolation", action="store_true", help="Enable isolation mode")
    parser.add_argument("--no-skip-daemon", action="store_true", 
                        help="Don't skip daemon initialization (default is to skip)")
    parser.add_argument("--persistence-path", 
                        help="Path for MCP server persistence files")
    parser.add_argument("--port", type=int, default=9992, 
                        help="Port to run the server on")
    parser.add_argument("--host", default="0.0.0.0", 
                        help="Host to bind to")
    parser.add_argument("--api-prefix", default="/api/v0", 
                        help="Prefix for API endpoints")
    parser.add_argument("--reload", action="store_true", 
                        help="Enable auto-reload (development only)")
    
    args = parser.parse_args()
    
    # Create the FastAPI app with configured MCP server
    try:
        debug_mode = args.debug
        isolation_mode = args.isolation
        skip_daemon = not args.no_skip_daemon  # Default is to skip daemon
        api_prefix = args.api_prefix
        
        app, mcp_server = create_app(
            debug_mode=debug_mode,
            isolation_mode=isolation_mode,
            skip_daemon=skip_daemon,
            persistence_path=args.persistence_path,
            api_prefix=api_prefix
        )
        
    except Exception as e:
        logger.error(f"Failed to create and configure MCP server: {e}")
        return 1
        
    # Start the server with uvicorn
    logger.info(f"Starting MCP server on port {args.port} with API prefix: {api_prefix}")
    logger.info(f"Debug mode: {debug_mode}, Isolation mode: {isolation_mode}, Skip daemon: {skip_daemon}")
    
    try:
        uvicorn.run(
            app, 
            host=args.host, 
            port=args.port,
            reload=args.reload,
            log_level="debug" if debug_mode else "info"
        )
    except Exception as e:
        logger.error(f"Error running uvicorn server: {e}")
        return 1
        
    logger.info("Server stopped")
    return 0

# This ensures app is accessible for uvicorn when using string reference
app, mcp_server = create_app()

# Enable graceful shutdown with signal handlers
def signal_handler(sig, frame):
    """Handle termination signals."""
    logger.info(f"Received signal {sig}, shutting down...")
    global mcp_server
    if mcp_server and hasattr(mcp_server, 'shutdown'):
        logger.info("Calling MCP server shutdown method...")
        try:
            mcp_server.shutdown()
        except Exception as e:
            logger.error(f"Error during MCP server shutdown: {e}")
    logger.info("Exiting...")
    sys.exit(0)

# Register signal handlers
signal.signal(signal.SIGINT, signal_handler)
signal.signal(signal.SIGTERM, signal_handler)

if __name__ == "__main__":
    sys.exit(main())