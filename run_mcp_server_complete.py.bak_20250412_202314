#!/usr/bin/env python3
"""
MCP server with real API implementations for all storage backends.
This provides a comprehensive integration of:
- HuggingFace
- S3
- Storacha (Web3.Storage)
- Filecoin
- Lassie
"""

import os
import sys
import time
import json
import logging
import importlib.util
from pathlib import Path
import uuid
import hashlib

from fastapi import FastAPI, APIRouter, Request, UploadFile, File, Form
from fastapi.responses import JSONResponse, FileResponse
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Get configuration from environment variables or use defaults
debug_mode = os.environ.get("MCP_DEBUG_MODE", "true").lower() == "true"
isolation_mode = os.environ.get("MCP_ISOLATION_MODE", "true").lower() == "true"
api_prefix = "/api/v0"  # Fixed prefix for consistency
persistence_path = os.environ.get("MCP_PERSISTENCE_PATH", "~/.ipfs_kit/mcp_debug")

# Configuration paths
CONFIG_DIR = Path.home() / ".ipfs_kit"
CREDENTIALS_FILE = CONFIG_DIR / "credentials.json"

def load_credentials():
    """Load credentials from file."""
    if CREDENTIALS_FILE.exists():
        try:
            with open(CREDENTIALS_FILE, "r") as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading credentials: {e}")
    return {}

# Load the credentials
credentials = load_credentials()

# Backend implementations
backend_implementations = {}

# Load backend implementations
def load_backend_implementations():
    """Load all backend implementations."""
    # HuggingFace implementation
    try:
        spec = importlib.util.spec_from_file_location("huggingface_real_api", "huggingface_real_api.py")
        huggingface_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(huggingface_module)
        
        # Get credentials
        hf_token = credentials.get("huggingface", {}).get("token")
        
        # Create implementation
        huggingface_api = huggingface_module.HuggingFaceRealAPI(
            token=hf_token,
            simulation_mode=os.environ.get("HUGGINGFACE_SIMULATION", "1") == "1"
        )
        
        backend_implementations["huggingface"] = huggingface_api
        logger.info(f"HuggingFace API initialized (simulation: {huggingface_api.simulation_mode})")
    except Exception as e:
        logger.error(f"Error loading HuggingFace implementation: {e}")
    
    # S3 implementation
    try:
        spec = importlib.util.spec_from_file_location("s3_real_api", "s3_real_api.py")
        s3_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(s3_module)
        
        # Get credentials
        s3_creds = credentials.get("s3", {})
        access_key = s3_creds.get("access_key") or s3_creds.get("aws_access_key_id")
        secret_key = s3_creds.get("secret_key") or s3_creds.get("aws_secret_access_key")
        region = s3_creds.get("region") or s3_creds.get("region_name") or "us-east-1"
        
        # Create implementation
        s3_api = s3_module.S3RealAPI(
            access_key=access_key,
            secret_key=secret_key,
            region=region,
            simulation_mode=os.environ.get("S3_SIMULATION", "1") == "1"
        )
        
        backend_implementations["s3"] = s3_api
        logger.info(f"S3 API initialized (simulation: {s3_api.simulation_mode})")
    except Exception as e:
        logger.error(f"Error loading S3 implementation: {e}")
    
    # Storacha implementation
    try:
        spec = importlib.util.spec_from_file_location("storacha_real_api", "storacha_real_api.py")
        storacha_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(storacha_module)
        
        # Get credentials
        storacha_creds = credentials.get("storacha", {})
        token = storacha_creds.get("token") or storacha_creds.get("web3storage_token")
        
        # Create implementation
        storacha_api = storacha_module.StorachaRealAPI(
            token=token,
            simulation_mode=os.environ.get("STORACHA_SIMULATION", "1") == "1"
        )
        
        backend_implementations["storacha"] = storacha_api
        logger.info(f"Storacha API initialized (simulation: {storacha_api.simulation_mode})")
    except Exception as e:
        logger.error(f"Error loading Storacha implementation: {e}")
    
    # Filecoin implementation
    try:
        spec = importlib.util.spec_from_file_location("filecoin_real_api", "filecoin_real_api.py")
        filecoin_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(filecoin_module)
        
        # Get credentials
        filecoin_creds = credentials.get("filecoin", {})
        api_token = filecoin_creds.get("api_token") or filecoin_creds.get("lotus_api_token")
        api_url = filecoin_creds.get("api_url") or filecoin_creds.get("lotus_api_url")
        
        # Create implementation
        filecoin_api = filecoin_module.FilecoinRealAPI(
            api_token=api_token,
            api_url=api_url,
            simulation_mode=os.environ.get("FILECOIN_SIMULATION", "1") == "1"
        )
        
        backend_implementations["filecoin"] = filecoin_api
        logger.info(f"Filecoin API initialized (simulation: {filecoin_api.simulation_mode})")
    except Exception as e:
        logger.error(f"Error loading Filecoin implementation: {e}")
    
    # Lassie implementation
    try:
        spec = importlib.util.spec_from_file_location("lassie_real_api", "lassie_real_api.py")
        lassie_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(lassie_module)
        
        # Create implementation - Lassie doesn't need credentials
        lassie_api = lassie_module.LassieRealAPI(
            simulation_mode=os.environ.get("LASSIE_SIMULATION", "1") == "1"
        )
        
        backend_implementations["lassie"] = lassie_api
        logger.info(f"Lassie API initialized (simulation: {lassie_api.simulation_mode})")
    except Exception as e:
        logger.error(f"Error loading Lassie implementation: {e}")

# Load all backend implementations
load_backend_implementations()

def create_app():
    """Create and configure the FastAPI app with MCP server."""
    # Create FastAPI app
    app = FastAPI(
        title="IPFS MCP Server",
        description="Model-Controller-Persistence Server for IPFS Kit with real storage backends",
        version="0.2.0"
    )
    
    # Add CORS middleware
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    # Add backend-specific endpoints
    add_backend_endpoints(app)
    
    # Add a custom pins endpoint that always works
    @app.get(f"{api_prefix}/mcp/cli/pins")
    async def list_pins():
        """Simple pins endpoint that always returns an empty list."""
        return {
            "success": True,
            "result": {
                "pins": {}
            },
            "operation_id": None,
            "format": None
        }
    
    # Import MCP server
    try:
        from ipfs_kit_py.mcp.server import MCPServer
        
        # Create MCP server
        mcp_server = MCPServer(
            debug_mode=debug_mode,
            isolation_mode=isolation_mode,
            persistence_path=os.path.expanduser(persistence_path)
        )
        
        # Register with app
        mcp_server.register_with_app(app, prefix=api_prefix)
        
        # Add root endpoint
        @app.get("/")
        async def root():
            """Root endpoint with API information."""
            # Get daemon status
            daemon_info = {}
            if hasattr(mcp_server.ipfs_kit, 'check_daemon_status'):
                try:
                    daemon_status = mcp_server.ipfs_kit.check_daemon_status()
                    for daemon_name, status in daemon_status.get("daemons", {}).items():
                        daemon_info[daemon_name] = {
                            "running": status.get("running", False),
                            "pid": status.get("pid")
                        }
                except Exception as e:
                    daemon_info["error"] = str(e)
                    
            # Available controllers
            controllers = list(mcp_server.controllers.keys())
            
            # Example endpoints
            example_endpoints = {
                "ipfs": {
                    "version": f"{api_prefix}/ipfs/version",
                    "add": f"{api_prefix}/ipfs/add",
                    "cat": f"{api_prefix}/ipfs/cat/{{cid}}",
                    "pin": f"{api_prefix}/ipfs/pin/add"
                },
                "storage": {}
            }
            
            # Add storage backend examples
            for backend in backend_implementations:
                example_endpoints["storage"][backend] = {
                    "status": f"{api_prefix}/{backend}/status"
                }
                
                # Add specific endpoint examples for each backend
                if backend == "huggingface":
                    example_endpoints["storage"][backend].update({
                        "from_ipfs": f"{api_prefix}/{backend}/from_ipfs",
                        "to_ipfs": f"{api_prefix}/{backend}/to_ipfs"
                    })
                elif backend == "s3":
                    example_endpoints["storage"][backend].update({
                        "from_ipfs": f"{api_prefix}/{backend}/from_ipfs",
                        "to_ipfs": f"{api_prefix}/{backend}/to_ipfs",
                        "list_buckets": f"{api_prefix}/{backend}/list_buckets"
                    })
                elif backend == "storacha":
                    example_endpoints["storage"][backend].update({
                        "from_ipfs": f"{api_prefix}/{backend}/from_ipfs",
                        "to_ipfs": f"{api_prefix}/{backend}/to_ipfs"
                    })
                elif backend == "filecoin":
                    example_endpoints["storage"][backend].update({
                        "from_ipfs": f"{api_prefix}/{backend}/from_ipfs",
                        "to_ipfs": f"{api_prefix}/{backend}/to_ipfs",
                        "check_deal": f"{api_prefix}/{backend}/check_deal/{{deal_id}}"
                    })
                elif backend == "lassie":
                    example_endpoints["storage"][backend].update({
                        "to_ipfs": f"{api_prefix}/{backend}/to_ipfs",
                        "fetch": f"{api_prefix}/{backend}/fetch/{{cid}}"
                    })
            
            # Help message about URL structure
            help_message = f"""
            The MCP server exposes endpoints under the {api_prefix} prefix.
            Controller endpoints use the pattern: {api_prefix}/{{controller}}/{{operation}}
            Storage backends are available at: {api_prefix}/{{backend}}/{{operation}}
            Examples:
            - IPFS Version: {api_prefix}/ipfs/version
            - Health Check: {api_prefix}/health
            - HuggingFace Status: {api_prefix}/huggingface/status
            """
            
            # Add backend status
            backend_status = {}
            for backend, impl in backend_implementations.items():
                status_info = impl.status()
                backend_status[backend] = {
                    "available": status_info.get("is_available", False),
                    "simulation": status_info.get("simulation", True),
                    "capabilities": status_info.get("capabilities", [])
                }
            
            return {
                "message": "MCP Server is running with real storage backends",
                "debug_mode": debug_mode,
                "isolation_mode": isolation_mode,
                "daemon_status": daemon_info,
                "controllers": controllers,
                "storage_backends": list(backend_implementations.keys()),
                "example_endpoints": example_endpoints,
                "backend_status": backend_status,
                "help": help_message,
                "documentation": "/docs"
            }
        
        # Add unified storage endpoints
        add_unified_storage_endpoints(app)
        
        return app, mcp_server
        
    except Exception as e:
        logger.error(f"Failed to initialize MCP server: {e}")
        app = FastAPI()
        
        @app.get("/")
        async def error():
            return {"error": f"Failed to initialize MCP server: {str(e)}"}
            
        return app, None

def add_backend_endpoints(app):
    """Add backend-specific endpoints to the app."""
    
    # For each backend, add its specific endpoints
    for backend, api in backend_implementations.items():
        # Common status endpoint for all backends
        @app.get(f"{api_prefix}/{backend}/status")
        async def status_endpoint(backend_name=backend, api_impl=api):
            """Get backend status."""
            return api_impl.status()
        
        # Use a function factory to create endpoints for each backend
        create_backend_endpoints(app, backend, api)

def create_backend_endpoints(app, backend_name, api):
    """Create specific endpoints for a backend."""
    backend = backend_name  # Keep original name for closures
    
    # API-specific endpoints based on backend type
    if backend == "huggingface":
        @app.post(f"{api_prefix}/{backend}/from_ipfs")
        async def huggingface_from_ipfs(request: Request):
            """Transfer content from IPFS to HuggingFace."""
            data = await request.json()
            cid = data.get("cid")
            repo_id = data.get("repo_id")
            path_in_repo = data.get("path_in_repo")
            
            if not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "CID is required"}
                )
                
            if not repo_id:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Repository ID is required"}
                )
            
            return api.from_ipfs(cid=cid, repo_id=repo_id, path_in_repo=path_in_repo)
        
        @app.post(f"{api_prefix}/{backend}/to_ipfs")
        async def huggingface_to_ipfs(request: Request):
            """Transfer content from HuggingFace to IPFS."""
            data = await request.json()
            repo_id = data.get("repo_id")
            path_in_repo = data.get("path_in_repo")
            
            if not repo_id:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Repository ID is required"}
                )
                
            if not path_in_repo:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Path in repository is required"}
                )
            
            return api.to_ipfs(repo_id=repo_id, path_in_repo=path_in_repo)
    
    elif backend == "s3":
        @app.post(f"{api_prefix}/{backend}/from_ipfs")
        async def s3_from_ipfs(request: Request):
            """Transfer content from IPFS to S3."""
            data = await request.json()
            cid = data.get("cid")
            bucket = data.get("bucket")
            key = data.get("key")
            
            if not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "CID is required"}
                )
                
            if not bucket:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Bucket is required"}
                )
            
            return api.from_ipfs(cid=cid, bucket=bucket, key=key)
        
        @app.post(f"{api_prefix}/{backend}/to_ipfs")
        async def s3_to_ipfs(request: Request):
            """Transfer content from S3 to IPFS."""
            data = await request.json()
            bucket = data.get("bucket")
            key = data.get("key")
            
            if not bucket:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Bucket is required"}
                )
                
            if not key:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Key is required"}
                )
            
            return api.to_ipfs(bucket=bucket, key=key)
        
        @app.get(f"{api_prefix}/{backend}/list_buckets")
        async def s3_list_buckets():
            """List S3 buckets."""
            return api.list_buckets()
        
        @app.post(f"{api_prefix}/{backend}/list_objects")
        async def s3_list_objects(request: Request):
            """List objects in an S3 bucket."""
            data = await request.json()
            bucket = data.get("bucket")
            prefix = data.get("prefix")
            
            if not bucket:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Bucket is required"}
                )
            
            return api.list_objects(bucket=bucket, prefix=prefix)
    
    elif backend == "storacha":
        @app.post(f"{api_prefix}/{backend}/from_ipfs")
        async def storacha_from_ipfs(request: Request):
            """Transfer content from IPFS to Storacha."""
            data = await request.json()
            cid = data.get("cid")
            
            if not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "CID is required"}
                )
            
            return api.from_ipfs(cid=cid)
        
        @app.post(f"{api_prefix}/{backend}/to_ipfs")
        async def storacha_to_ipfs(request: Request):
            """Transfer content from Storacha to IPFS."""
            data = await request.json()
            car_cid = data.get("car_cid")
            cid = data.get("cid")
            
            if not car_cid and not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Either car_cid or cid is required"}
                )
            
            return api.to_ipfs(car_cid=car_cid, cid=cid)
        
        @app.get(f"{api_prefix}/{backend}/list_uploads")
        async def storacha_list_uploads(limit: int = 10):
            """List uploads on Storacha."""
            return api.list_uploads(limit=limit)
    
    elif backend == "filecoin":
        @app.post(f"{api_prefix}/{backend}/from_ipfs")
        async def filecoin_from_ipfs(request: Request):
            """Transfer content from IPFS to Filecoin."""
            data = await request.json()
            cid = data.get("cid")
            
            if not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "CID is required"}
                )
            
            return api.from_ipfs(cid=cid)
        
        @app.post(f"{api_prefix}/{backend}/to_ipfs")
        async def filecoin_to_ipfs(request: Request):
            """Transfer content from Filecoin to IPFS."""
            data = await request.json()
            deal_id = data.get("deal_id")
            
            if not deal_id:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Deal ID is required"}
                )
            
            return api.to_ipfs(deal_id=deal_id)
        
        @app.get(f"{api_prefix}/{backend}/check_deal/{{deal_id}}")
        async def filecoin_check_deal(deal_id: str):
            """Check status of a Filecoin deal."""
            return api.check_deal(deal_id=deal_id)
        
        @app.get(f"{api_prefix}/{backend}/list_deals")
        async def filecoin_list_deals(limit: int = 10):
            """List Filecoin deals."""
            return api.list_deals(limit=limit)
    
    elif backend == "lassie":
        @app.post(f"{api_prefix}/{backend}/to_ipfs")
        async def lassie_to_ipfs(request: Request):
            """Retrieve content with Lassie and add to IPFS."""
            data = await request.json()
            cid = data.get("cid")
            
            if not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "CID is required"}
                )
            
            return api.to_ipfs(cid=cid)
        
        @app.get(f"{api_prefix}/{backend}/fetch/{{cid}}")
        async def lassie_fetch(cid: str, output: str = None):
            """Fetch content with Lassie."""
            result = api.fetch(cid=cid, output_path=output)
            
            if not result.get("success", False):
                return JSONResponse(
                    status_code=500,
                    content=result
                )
            
            # If output path is specified and exists, return its path in the result
            # Otherwise, return the result directly
            if output and os.path.exists(output):
                result["path"] = output
                return result
            elif "output_path" in result and os.path.exists(result["output_path"]):
                # If we want to return the file directly
                # return FileResponse(result["output_path"])
                # For now, just return the path
                return result
            else:
                return result
        
        @app.get(f"{api_prefix}/{backend}/fetch_car/{{cid}}")
        async def lassie_fetch_car(cid: str, output: str = None):
            """Fetch content as CAR file with Lassie."""
            result = api.fetch_car(cid=cid, output_path=output)
            
            if not result.get("success", False):
                return JSONResponse(
                    status_code=500,
                    content=result
                )
            
            # Return the result with the path
            return result

def add_unified_storage_endpoints(app):
    """Add unified storage endpoints that can work with any backend."""
    
    @app.get(f"{api_prefix}/storage/backends")
    async def list_storage_backends():
        """List all available storage backends."""
        backends = []
        
        for backend, api in backend_implementations.items():
            status = api.status()
            backends.append({
                "name": backend,
                "available": status.get("is_available", False),
                "simulation": status.get("simulation", True),
                "capabilities": status.get("capabilities", [])
            })
        
        return {
            "success": True,
            "operation_id": f"list_backends_{int(time.time() * 1000)}",
            "backends": backends,
            "count": len(backends)
        }
    
    @app.post(f"{api_prefix}/storage/store")
    async def store_to_backend(request: Request):
        """Store content to a specific backend."""
        data = await request.json()
        backend = data.get("backend")
        source_type = data.get("source_type", "ipfs")
        source_params = data.get("source_params", {})
        
        if not backend:
            return JSONResponse(
                status_code=422,
                content={"success": False, "error": "Backend is required"}
            )
        
        if backend not in backend_implementations:
            return JSONResponse(
                status_code=404,
                content={"success": False, "error": f"Backend not found: {backend}"}
            )
        
        # Currently only supports IPFS as source
        if source_type != "ipfs":
            return JSONResponse(
                status_code=422,
                content={"success": False, "error": f"Unsupported source type: {source_type}"}
            )
        
        # Get CID from source params
        cid = source_params.get("cid")
        if not cid:
            return JSONResponse(
                status_code=422,
                content={"success": False, "error": "CID is required in source_params"}
            )
        
        # Handle backend-specific parameters
        backend_params = data.get("backend_params", {})
        
        # Call the appropriate backend method
        api = backend_implementations[backend]
        
        if backend == "huggingface":
            repo_id = backend_params.get("repo_id")
            path_in_repo = backend_params.get("path_in_repo")
            
            if not repo_id:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "repo_id is required for HuggingFace"}
                )
            
            return api.from_ipfs(cid=cid, repo_id=repo_id, path_in_repo=path_in_repo)
        
        elif backend == "s3":
            bucket = backend_params.get("bucket")
            key = backend_params.get("key")
            
            if not bucket:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "bucket is required for S3"}
                )
            
            return api.from_ipfs(cid=cid, bucket=bucket, key=key)
        
        elif backend == "storacha":
            return api.from_ipfs(cid=cid)
        
        elif backend == "filecoin":
            return api.from_ipfs(cid=cid)
        
        elif backend == "lassie":
            return JSONResponse(
                status_code=422,
                content={"success": False, "error": "Lassie is a retrieval service, not a storage service"}
            )
    
    @app.post(f"{api_prefix}/storage/retrieve")
    async def retrieve_from_backend(request: Request):
        """Retrieve content from a specific backend."""
        data = await request.json()
        backend = data.get("backend")
        target_type = data.get("target_type", "ipfs")
        backend_params = data.get("backend_params", {})
        
        if not backend:
            return JSONResponse(
                status_code=422,
                content={"success": False, "error": "Backend is required"}
            )
        
        if backend not in backend_implementations:
            return JSONResponse(
                status_code=404,
                content={"success": False, "error": f"Backend not found: {backend}"}
            )
        
        # Currently only supports IPFS as target
        if target_type != "ipfs":
            return JSONResponse(
                status_code=422,
                content={"success": False, "error": f"Unsupported target type: {target_type}"}
            )
        
        # Call the appropriate backend method
        api = backend_implementations[backend]
        
        if backend == "huggingface":
            repo_id = backend_params.get("repo_id")
            path_in_repo = backend_params.get("path_in_repo")
            
            if not repo_id or not path_in_repo:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "repo_id and path_in_repo are required for HuggingFace"}
                )
            
            return api.to_ipfs(repo_id=repo_id, path_in_repo=path_in_repo)
        
        elif backend == "s3":
            bucket = backend_params.get("bucket")
            key = backend_params.get("key")
            
            if not bucket or not key:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "bucket and key are required for S3"}
                )
            
            return api.to_ipfs(bucket=bucket, key=key)
        
        elif backend == "storacha":
            car_cid = backend_params.get("car_cid")
            cid = backend_params.get("cid")
            
            if not car_cid and not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "Either car_cid or cid is required for Storacha"}
                )
            
            return api.to_ipfs(car_cid=car_cid, cid=cid)
        
        elif backend == "filecoin":
            deal_id = backend_params.get("deal_id")
            
            if not deal_id:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "deal_id is required for Filecoin"}
                )
            
            return api.to_ipfs(deal_id=deal_id)
        
        elif backend == "lassie":
            cid = backend_params.get("cid")
            
            if not cid:
                return JSONResponse(
                    status_code=422,
                    content={"success": False, "error": "cid is required for Lassie"}
                )
            
            return api.to_ipfs(cid=cid)

# Create the app for uvicorn
app, mcp_server = create_app()

if __name__ == "__main__":
    # Run uvicorn directly
    port = int(os.environ.get("MCP_PORT", "9992"))
    logger.info(f"Starting MCP server with real storage backends on port {port}")
    logger.info(f"Debug mode: {debug_mode}, Isolation mode: {isolation_mode}")
    
    # Log backend status
    for backend, api in backend_implementations.items():
        status = api.status()
        mode = "SIMULATION" if status.get("simulation", True) else "REAL"
        logger.info(f"Backend {backend}: {mode} mode, Available: {status.get('is_available', False)}")
    
    uvicorn.run(
        "run_mcp_server_complete:app", 
        host="0.0.0.0", 
        port=port,
        reload=False,
        log_level="info"
    )