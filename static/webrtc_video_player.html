<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Video Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #333;
        }
        .header h1 {
            margin: 0;
            color: #fff;
        }
        
        .video-container {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .video-wrapper {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
        }
        
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
        }
        
        .player-controls {
            background-color: rgba(0,0,0,0.7);
            padding: 15px;
            border-bottom-left-radius: 8px;
            border-bottom-right-radius: 8px;
        }
        
        .player-controls-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .timeline {
            flex-grow: 1;
            height: 8px;
            background-color: #444;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            cursor: pointer;
        }
        
        .timeline-progress {
            height: 100%;
            background-color: #3498db;
            width: 0%;
            transition: width 0.1s;
        }
        
        .timeline-buffered {
            position: absolute;
            height: 100%;
            background-color: rgba(255,255,255,0.2);
            width: 0%;
            top: 0;
            left: 0;
        }
        
        .time-display {
            font-family: monospace;
            font-size: 14px;
            min-width: 100px;
            text-align: center;
        }
        
        .control-button {
            background-color: transparent;
            border: none;
            color: white;
            font-size: 16px;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .control-button:hover {
            background-color: rgba(255,255,255,0.1);
        }
        
        .control-button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .volume-slider {
            width: 80px;
            -webkit-appearance: none;
            height: 5px;
            border-radius: 2.5px;
            background: #444;
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
        }
        
        .volume-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #3498db;
            cursor: pointer;
            border: none;
        }
        
        .connection-panel {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }
        
        .form-control {
            width: 100%;
            padding: 10px 12px;
            font-size: 14px;
            background-color: #333;
            border: 1px solid #444;
            border-radius: 4px;
            color: #f0f0f0;
            box-sizing: border-box;
        }
        
        .form-btn {
            background-color: #3498db;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            margin-right: 10px;
        }
        
        .form-btn.danger {
            background-color: #e74c3c;
        }
        
        .form-btn:hover {
            opacity: 0.9;
        }
        
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            margin-left: 10px;
        }
        
        .status-connected {
            background-color: #2ecc71;
            color: #fff;
        }
        
        .status-disconnected {
            background-color: #e74c3c;
            color: #fff;
        }
        
        .status-connecting {
            background-color: #f39c12;
            color: #fff;
        }
        
        .log-container {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            margin-bottom: 20px;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 12px;
        }
        
        .log-timestamp {
            color: #888;
            margin-right: 10px;
        }
        
        .log-error {
            color: #e74c3c;
        }
        
        .log-success {
            color: #2ecc71;
        }
        
        .log-info {
            color: #3498db;
        }
        
        .advanced-panel {
            background-color: #2c2c2c;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .panel-heading {
            margin-top: 0;
            margin-bottom: 15px;
            color: #fff;
            font-size: 18px;
            font-weight: 600;
        }
        
        .random-seek-controls {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }
        
        .seek-options {
            flex-grow: 1;
            display: flex;
            gap: 15px;
        }
        
        .stats-display {
            margin-top: 15px;
            padding: 10px;
            background-color: #333;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .dropdown-panel {
            margin-top: 15px;
        }
        
        .dropdown-heading {
            background-color: #333;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .dropdown-heading:hover {
            background-color: #3a3a3a;
        }
        
        .dropdown-content {
            padding: 15px;
            background-color: #333;
            border-radius: 0 0 4px 4px;
            margin-top: 2px;
            display: none;
        }
        
        .dropdown-open .dropdown-content {
            display: block;
        }
        
        .loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 50%;
            z-index: 10;
        }
        
        .loading-indicator svg {
            width: 40px;
            height: 40px;
            animation: spin 1.5s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>WebRTC Video Player</h1>
            <div style="display: flex; align-items: center;">
                <a href="/api/v0/webrtc/dashboard" class="form-btn" style="margin-right: 10px;">Back to Dashboard</a>
                <span id="connection-status" class="status-badge status-disconnected">Disconnected</span>
            </div>
        </div>
        
        <div class="connection-panel">
            <h2 class="panel-heading">Content Connection</h2>
            <div class="form-group">
                <label for="content-cid">Content CID:</label>
                <input type="text" id="content-cid" class="form-control" placeholder="QmExample...">
            </div>
            <div class="form-group">
                <label for="quality">Stream Quality (0-100):</label>
                <input type="number" id="quality" class="form-control" value="80" min="0" max="100">
            </div>
            <button id="connect-btn" class="form-btn">Connect & Stream</button>
            <button id="disconnect-btn" class="form-btn danger">Disconnect</button>
        </div>
        
        <div class="video-container">
            <div class="video-wrapper">
                <video id="video-player" autoplay playsinline></video>
                <div id="loading-indicator" class="loading-indicator hidden">
                    <svg viewBox="0 0 24 24">
                        <path d="M12,4V2A10,10 0 0,0 2,12H4A8,8 0 0,1 12,4Z" fill="#ffffff"></path>
                    </svg>
                </div>
            </div>
            <div class="player-controls">
                <div class="player-controls-row">
                    <div class="timeline" id="timeline">
                        <div class="timeline-buffered" id="buffered-progress"></div>
                        <div class="timeline-progress" id="play-progress"></div>
                    </div>
                    <div class="time-display" id="time-display">00:00 / 00:00</div>
                </div>
                <div class="player-controls-row">
                    <button id="play-pause-btn" class="control-button" title="Play">
                        <svg viewBox="0 0 24 24">
                            <path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path>
                        </svg>
                    </button>
                    <button id="stop-btn" class="control-button" title="Stop">
                        <svg viewBox="0 0 24 24">
                            <path d="M18,18H6V6H18V18Z"></path>
                        </svg>
                    </button>
                    <button id="backward-btn" class="control-button" title="Back 10s">
                        <svg viewBox="0 0 24 24">
                            <path d="M12,5V1L7,6L12,11V7A6,6 0 0,1 18,13A6,6 0 0,1 12,19A6,6 0 0,1 6,13H4A8,8 0 0,0 12,21A8,8 0 0,0 20,13A8,8 0 0,0 12,5M10,19H8V17H10V19M7,17H5V15H7V17M11,19V17H13V19H11M14,17V15H16V17H14Z"></path>
                        </svg>
                    </button>
                    <button id="forward-btn" class="control-button" title="Forward 10s">
                        <svg viewBox="0 0 24 24">
                            <path d="M10,12V10H8V12H10M12,12H14V10H12V12M16,12H18V10H16V12M20,18V8H4V18H20M20,6A2,2 0 0,1 22,8V18A2,2 0 0,1 20,20H4A2,2 0 0,1 2,18V8A2,2 0 0,1 4,6H20M16,16H8V14H16V16Z"></path>
                        </svg>
                    </button>
                    <div class="volume-control">
                        <button id="mute-btn" class="control-button" title="Mute">
                            <svg viewBox="0 0 24 24">
                                <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"></path>
                            </svg>
                        </button>
                        <input type="range" id="volume-slider" class="volume-slider" min="0" max="1" step="0.01" value="0.7">
                    </div>
                    <button id="fullscreen-btn" class="control-button" title="Fullscreen">
                        <svg viewBox="0 0 24 24">
                            <path d="M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>
        
        <div class="advanced-panel">
            <h2 class="panel-heading">Random Seek Controls</h2>
            <div class="random-seek-controls">
                <div class="seek-options">
                    <div class="form-group">
                        <label for="seek-interval">Seek Interval (seconds):</label>
                        <input type="number" id="seek-interval" class="form-control" value="5" min="1" max="60">
                    </div>
                    <div class="form-group">
                        <label for="seek-probability">Seek Probability (%):</label>
                        <input type="number" id="seek-probability" class="form-control" value="20" min="1" max="100">
                    </div>
                </div>
                <button id="toggle-random-seek" class="form-btn">Start Random Seeking</button>
            </div>
            
            <div class="stats-display" id="seek-stats">
                Random seeking disabled
            </div>
            
            <div class="dropdown-panel" id="connection-info-dropdown">
                <div class="dropdown-heading">
                    <span>Connection Information</span>
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path d="M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z" fill="currentColor"></path>
                    </svg>
                </div>
                <div class="dropdown-content">
                    <div id="connection-info">No active connection</div>
                </div>
            </div>
        </div>
        
        <div class="log-container" id="player-log">
            <!-- Log entries will be added here -->
        </div>
    </div>

    <script>
        // Constants
        const API_BASE = '/api/v0/webrtc';
        
        // State variables
        let currentConnection = null;
        let player = document.getElementById('video-player');
        let peerConnection = null;
        let randomSeekInterval = null;
        let isRandomSeeking = false;
        let seekCount = 0;
        let seekStats = {
            total: 0,
            forward: 0,
            backward: 0,
            locations: {},
            startTime: null
        };
        
        // DOM elements
        const connectBtn = document.getElementById('connect-btn');
        const disconnectBtn = document.getElementById('disconnect-btn');
        const cidInput = document.getElementById('content-cid');
        const qualityInput = document.getElementById('quality');
        const connectionStatus = document.getElementById('connection-status');
        const loadingIndicator = document.getElementById('loading-indicator');
        const timelineEl = document.getElementById('timeline');
        const playProgressEl = document.getElementById('play-progress');
        const bufferedProgressEl = document.getElementById('buffered-progress');
        const timeDisplayEl = document.getElementById('time-display');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const stopBtn = document.getElementById('stop-btn');
        const backwardBtn = document.getElementById('backward-btn');
        const forwardBtn = document.getElementById('forward-btn');
        const muteBtn = document.getElementById('mute-btn');
        const volumeSlider = document.getElementById('volume-slider');
        const fullscreenBtn = document.getElementById('fullscreen-btn');
        const seekIntervalInput = document.getElementById('seek-interval');
        const seekProbabilityInput = document.getElementById('seek-probability');
        const toggleRandomSeekBtn = document.getElementById('toggle-random-seek');
        const seekStatsEl = document.getElementById('seek-stats');
        const playerLog = document.getElementById('player-log');
        const connectionInfoDropdown = document.getElementById('connection-info-dropdown');
        const connectionInfoEl = document.getElementById('connection-info');
        
        // Initialize player
        function initPlayer() {
            // Set up event listeners for player
            player.addEventListener('loadedmetadata', onMetadataLoaded);
            player.addEventListener('timeupdate', onTimeUpdate);
            player.addEventListener('progress', onProgress);
            player.addEventListener('waiting', onWaiting);
            player.addEventListener('playing', onPlaying);
            player.addEventListener('ended', onEnded);
            player.addEventListener('error', onPlayerError);
            
            // Set up event listeners for controls
            playPauseBtn.addEventListener('click', togglePlayPause);
            stopBtn.addEventListener('click', stopPlayer);
            backwardBtn.addEventListener('click', seekBackward);
            forwardBtn.addEventListener('click', seekForward);
            muteBtn.addEventListener('click', toggleMute);
            volumeSlider.addEventListener('input', updateVolume);
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            timelineEl.addEventListener('click', seekToPosition);
            
            // Connection controls
            connectBtn.addEventListener('click', connectStream);
            disconnectBtn.addEventListener('click', disconnectStream);
            
            // Random seek controls
            toggleRandomSeekBtn.addEventListener('click', toggleRandomSeek);
            
            // Dropdown toggles
            connectionInfoDropdown.querySelector('.dropdown-heading').addEventListener('click', function() {
                connectionInfoDropdown.classList.toggle('dropdown-open');
            });
            
            // Initial volume
            updateVolume();
            
            // Log initialization
            addLogEntry('Player initialized', 'info');
        }
        
        // Player event handlers
        function onMetadataLoaded() {
            addLogEntry(`Video metadata loaded. Duration: ${formatTime(player.duration)}`, 'info');
            updateTimeDisplay();
        }
        
        function onTimeUpdate() {
            // Update progress bar
            const percent = (player.currentTime / player.duration) * 100;
            playProgressEl.style.width = `${percent}%`;
            
            // Update time display
            updateTimeDisplay();
        }
        
        function onProgress() {
            // Update buffered progress
            if (player.buffered.length > 0) {
                const bufferedEnd = player.buffered.end(player.buffered.length - 1);
                const duration = player.duration;
                const bufferedPercent = (bufferedEnd / duration) * 100;
                bufferedProgressEl.style.width = `${bufferedPercent}%`;
            }
        }
        
        function onWaiting() {
            addLogEntry('Video buffering...', 'info');
            loadingIndicator.classList.remove('hidden');
        }
        
        function onPlaying() {
            loadingIndicator.classList.add('hidden');
            
            // Update play/pause button
            playPauseBtn.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M14,19H18V5H14M6,19H10V5H6V19Z"></path>
                </svg>
            `;
            playPauseBtn.title = 'Pause';
        }
        
        function onEnded() {
            addLogEntry('Video playback ended', 'info');
            
            // Update play/pause button
            playPauseBtn.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path>
                </svg>
            `;
            playPauseBtn.title = 'Play';
            
            // Stop random seeking if active
            if (isRandomSeeking) {
                toggleRandomSeek();
            }
        }
        
        function onPlayerError(error) {
            addLogEntry(`Player error: ${error.message || 'Unknown error'}`, 'error');
            loadingIndicator.classList.add('hidden');
        }
        
        // Player control functions
        function togglePlayPause() {
            if (player.paused) {
                player.play();
                playPauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M14,19H18V5H14M6,19H10V5H6V19Z"></path>
                    </svg>
                `;
                playPauseBtn.title = 'Pause';
                addLogEntry('Playback started', 'info');
            } else {
                player.pause();
                playPauseBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path>
                    </svg>
                `;
                playPauseBtn.title = 'Play';
                addLogEntry('Playback paused', 'info');
            }
        }
        
        function stopPlayer() {
            player.pause();
            player.currentTime = 0;
            playPauseBtn.innerHTML = `
                <svg viewBox="0 0 24 24">
                    <path d="M8,5.14V19.14L19,12.14L8,5.14Z"></path>
                </svg>
            `;
            playPauseBtn.title = 'Play';
            addLogEntry('Playback stopped', 'info');
            
            // Stop random seeking if active
            if (isRandomSeeking) {
                toggleRandomSeek();
            }
        }
        
        function seekBackward() {
            const newTime = Math.max(0, player.currentTime - 10);
            player.currentTime = newTime;
            addLogEntry(`Seeking backward to ${formatTime(newTime)}`, 'info');
        }
        
        function seekForward() {
            const newTime = Math.min(player.duration, player.currentTime + 10);
            player.currentTime = newTime;
            addLogEntry(`Seeking forward to ${formatTime(newTime)}`, 'info');
        }
        
        function toggleMute() {
            player.muted = !player.muted;
            
            if (player.muted) {
                muteBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M12,4L9.91,6.09L12,8.18M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z"></path>
                    </svg>
                `;
                muteBtn.title = 'Unmute';
                volumeSlider.disabled = true;
                addLogEntry('Audio muted', 'info');
            } else {
                muteBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"></path>
                    </svg>
                `;
                muteBtn.title = 'Mute';
                volumeSlider.disabled = false;
                addLogEntry('Audio unmuted', 'info');
            }
        }
        
        function updateVolume() {
            const value = volumeSlider.value;
            player.volume = value;
            
            // Update volume icon based on level
            if (value > 0.5) {
                muteBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z"></path>
                    </svg>
                `;
            } else if (value > 0) {
                muteBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M5,9V15H9L14,20V4L9,9M18.5,12C18.5,10.23 17.5,8.71 16,7.97V16C17.5,15.29 18.5,13.76 18.5,12Z"></path>
                    </svg>
                `;
            } else {
                muteBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M12,4L9.91,6.09L12,8.18M4.27,3L3,4.27L7.73,9H3V15H7L12,20V13.27L16.25,17.53C15.58,18.04 14.83,18.46 14,18.7V20.77C15.38,20.45 16.63,19.82 17.68,18.96L19.73,21L21,19.73L12,10.73M19,12C19,12.94 18.8,13.82 18.46,14.64L19.97,16.15C20.62,14.91 21,13.5 21,12C21,7.72 18,4.14 14,3.23V5.29C16.89,6.15 19,8.83 19,12M16.5,12C16.5,10.23 15.5,8.71 14,7.97V10.18L16.45,12.63C16.5,12.43 16.5,12.21 16.5,12Z"></path>
                    </svg>
                `;
            }
        }
        
        function toggleFullscreen() {
            const videoContainer = document.querySelector('.video-container');
            
            if (!document.fullscreenElement) {
                if (videoContainer.requestFullscreen) {
                    videoContainer.requestFullscreen();
                } else if (videoContainer.mozRequestFullScreen) {
                    videoContainer.mozRequestFullScreen();
                } else if (videoContainer.webkitRequestFullscreen) {
                    videoContainer.webkitRequestFullscreen();
                } else if (videoContainer.msRequestFullscreen) {
                    videoContainer.msRequestFullscreen();
                }
                fullscreenBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M5,16H8V19H10V14H5V16M14,14V19H16V16H19V14H14M8,5V8H5V10H10V5H8M14,5V10H19V8H16V5H14Z"></path>
                    </svg>
                `;
                fullscreenBtn.title = 'Exit Fullscreen';
                addLogEntry('Entered fullscreen mode', 'info');
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                fullscreenBtn.innerHTML = `
                    <svg viewBox="0 0 24 24">
                        <path d="M5,5H10V7H7V10H5V5M14,5H19V10H17V7H14V5M17,14H19V19H14V17H17V14M10,17V19H5V14H7V17H10Z"></path>
                    </svg>
                `;
                fullscreenBtn.title = 'Fullscreen';
                addLogEntry('Exited fullscreen mode', 'info');
            }
        }
        
        function seekToPosition(event) {
            const rect = timelineEl.getBoundingClientRect();
            const pos = (event.clientX - rect.left) / rect.width;
            const seekTime = player.duration * pos;
            player.currentTime = seekTime;
            addLogEntry(`Seeking to ${formatTime(seekTime)}`, 'info');
        }
        
        function updateTimeDisplay() {
            const currentTime = formatTime(player.currentTime);
            const duration = formatTime(player.duration);
            timeDisplayEl.textContent = `${currentTime} / ${duration}`;
        }
        
        // Format time in MM:SS format
        function formatTime(seconds) {
            if (isNaN(seconds)) return "00:00";
            
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }
        
        // Connection functions
        async function connectStream() {
            const contentCid = cidInput.value.trim();
            const quality = parseInt(qualityInput.value, 10);
            
            if (!contentCid) {
                addLogEntry('Please enter a content CID', 'error');
                return;
            }
            
            // Update UI
            connectionStatus.textContent = 'Connecting';
            connectionStatus.className = 'status-badge status-connecting';
            loadingIndicator.classList.remove('hidden');
            addLogEntry(`Connecting to stream for CID: ${contentCid}`, 'info');
            
            try {
                // Make API request to start streaming
                const response = await fetch(`${API_BASE}/stream`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        cid: contentCid,
                        quality: quality
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    // Store connection details
                    currentConnection = {
                        id: result.connection_id,
                        cid: contentCid,
                        quality: quality,
                        startTime: new Date()
                    };
                    
                    // Update UI
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.className = 'status-badge status-connected';
                    addLogEntry(`Connection established. ID: ${result.connection_id}`, 'success');
                    
                    // Set up WebRTC
                    await setupWebRTC(result.connection_id);
                    
                    // Update connection info
                    updateConnectionInfo();
                } else {
                    throw new Error(result.error || 'Failed to connect');
                }
            } catch (error) {
                connectionStatus.textContent = 'Disconnected';
                connectionStatus.className = 'status-badge status-disconnected';
                loadingIndicator.classList.add('hidden');
                addLogEntry(`Connection failed: ${error.message}`, 'error');
            }
        }
        
        async function disconnectStream() {
            if (!currentConnection) {
                addLogEntry('No active connection to disconnect', 'info');
                return;
            }
            
            try {
                // Make API request to close connection
                const response = await fetch(`${API_BASE}/close/${currentConnection.id}`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error ${response.status}`);
                }
                
                const result = await response.json();
                
                // Clean up WebRTC
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                
                // Stop video
                player.pause();
                player.srcObject = null;
                
                // Update UI
                connectionStatus.textContent = 'Disconnected';
                connectionStatus.className = 'status-badge status-disconnected';
                
                // Stop random seeking if active
                if (isRandomSeeking) {
                    toggleRandomSeek();
                }
                
                // Log result
                if (result.success) {
                    addLogEntry(`Connection ${currentConnection.id} closed successfully`, 'success');
                } else {
                    addLogEntry(`Connection close response: ${result.error || 'Unknown error'}`, 'warning');
                }
                
                // Clear current connection
                currentConnection = null;
                updateConnectionInfo();
                
            } catch (error) {
                addLogEntry(`Error closing connection: ${error.message}`, 'error');
            }
        }
        
        async function setupWebRTC(connectionId) {
            try {
                // Set up event handlers for WebRTC
                player.oncanplay = function() {
                    loadingIndicator.classList.add('hidden');
                    player.play();
                };
                
                // Create dummy connection for example
                // In a real implementation, this would be the actual WebRTC connection setup
                peerConnection = {
                    close: function() {
                        addLogEntry('WebRTC connection closed', 'info');
                    }
                };
                
                // For demo purposes, we're using a local video file
                const demoVideo = '/static/demo_video.mp4';
                player.src = demoVideo;
                
                addLogEntry('WebRTC setup complete, waiting for video to load', 'info');
                
                return true;
            } catch (error) {
                addLogEntry(`WebRTC setup error: ${error.message}`, 'error');
                loadingIndicator.classList.add('hidden');
                throw error;
            }
        }
        
        // Random seek functions
        function toggleRandomSeek() {
            if (isRandomSeeking) {
                // Stop random seeking
                clearInterval(randomSeekInterval);
                isRandomSeeking = false;
                toggleRandomSeekBtn.textContent = 'Start Random Seeking';
                addLogEntry('Random seeking stopped', 'info');
                
                // Update stats with final information
                updateSeekStats();
            } else {
                // Start random seeking
                if (!player.duration) {
                    addLogEntry('Cannot start random seeking: No video loaded', 'error');
                    return;
                }
                
                // Reset stats
                seekStats = {
                    total: 0,
                    forward: 0,
                    backward: 0,
                    locations: {},
                    startTime: new Date()
                };
                
                // Get parameters
                const interval = parseInt(seekIntervalInput.value, 10) * 1000; // Convert to ms
                const probability = parseInt(seekProbabilityInput.value, 10);
                
                // Start interval
                isRandomSeeking = true;
                randomSeekInterval = setInterval(() => performRandomSeek(probability), interval);
                toggleRandomSeekBtn.textContent = 'Stop Random Seeking';
                addLogEntry(`Random seeking started (${probability}% chance every ${interval/1000}s)`, 'info');
                
                // Initial stats update
                updateSeekStats();
            }
        }
        
        function performRandomSeek(probability) {
            // Check if video is ready
            if (!player.duration || player.paused || player.ended) {
                return;
            }
            
            // Roll dice to see if we should seek
            if (Math.random() * 100 > probability) {
                return;
            }
            
            // Choose a random position in the video
            const randomPosition = Math.random() * player.duration;
            const previousPosition = player.currentTime;
            
            // Determine seek direction
            const isForward = randomPosition > previousPosition;
            
            // Update stats
            seekStats.total++;
            if (isForward) {
                seekStats.forward++;
            } else {
                seekStats.backward++;
            }
            
            // Track location buckets (10 second intervals)
            const bucket = Math.floor(randomPosition / 10) * 10;
            seekStats.locations[bucket] = (seekStats.locations[bucket] || 0) + 1;
            
            // Perform the seek
            player.currentTime = randomPosition;
            
            // Log the seek
            addLogEntry(`Random seek to ${formatTime(randomPosition)} (${isForward ? 'forward' : 'backward'})`, 'info');
            
            // Update stats display
            updateSeekStats();
        }
        
        function updateSeekStats() {
            if (!isRandomSeeking && !seekStats.total) {
                seekStatsEl.textContent = 'Random seeking disabled';
                return;
            }
            
            // Calculate duration
            const duration = seekStats.startTime ? 
                Math.round((new Date() - seekStats.startTime) / 1000) : 0;
            
            // Get top 3 most frequent locations
            const sortedLocations = Object.entries(seekStats.locations)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 3)
                .map(([bucket, count]) => `${formatTime(parseInt(bucket))}-${formatTime(parseInt(bucket) + 10)}: ${count}`)
                .join(', ');
            
            // Build stats string
            const statsStr = `
                Running for: ${formatTime(duration)}
                Total seeks: ${seekStats.total}
                Forward: ${seekStats.forward} (${Math.round(seekStats.forward/Math.max(1, seekStats.total)*100)}%)
                Backward: ${seekStats.backward} (${Math.round(seekStats.backward/Math.max(1, seekStats.total)*100)}%)
                Rate: ${duration ? (seekStats.total / duration * 60).toFixed(2) : 0} seeks/minute
                Top locations: ${sortedLocations || 'None'}
            `;
            
            seekStatsEl.textContent = statsStr;
        }
        
        function updateConnectionInfo() {
            if (!currentConnection) {
                connectionInfoEl.textContent = 'No active connection';
                return;
            }
            
            const duration = currentConnection.startTime ?
                Math.round((new Date() - currentConnection.startTime) / 1000) : 0;
            
            const infoStr = `
                Connection ID: ${currentConnection.id}
                Content CID: ${currentConnection.cid}
                Quality: ${currentConnection.quality}
                Duration: ${formatTime(duration)}
                Connected at: ${currentConnection.startTime.toLocaleTimeString()}
            `;
            
            connectionInfoEl.textContent = infoStr;
        }
        
        // Logger
        function addLogEntry(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            
            const timestamp = document.createElement('span');
            timestamp.className = 'log-timestamp';
            timestamp.textContent = new Date().toLocaleTimeString();
            
            entry.appendChild(timestamp);
            entry.appendChild(document.createTextNode(' ' + message));
            
            playerLog.insertBefore(entry, playerLog.firstChild);
            
            // Limit to 100 entries
            const entries = playerLog.querySelectorAll('.log-entry');
            if (entries.length > 100) {
                playerLog.removeChild(entries[entries.length - 1]);
            }
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initPlayer();
            
            // Set default CID for testing
            cidInput.value = "QmTestContent";
            
            // Add initial log entry
            addLogEntry('WebRTC Video Player loaded', 'info');
            
            // Set interval to update connection info
            setInterval(updateConnectionInfo, 1000);
        });
    </script>
</body>
</html>