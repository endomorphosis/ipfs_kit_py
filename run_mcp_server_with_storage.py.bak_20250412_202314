#!/usr/bin/env python3
"""
Improved script to run the MCP server with direct route registration.
"""

import os
import logging
import time
import hashlib
from fastapi import FastAPI, APIRouter, Request
from fastapi.responses import JSONResponse

import uvicorn
from fastapi import FastAPI, APIRouter

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Get configuration from environment variables or use defaults
debug_mode = os.environ.get("MCP_DEBUG_MODE", "true").lower() == "true"
isolation_mode = os.environ.get("MCP_ISOLATION_MODE", "true").lower() == "true"
api_prefix = "/api/v0"  # Fixed prefix for consistency
persistence_path = os.environ.get("MCP_PERSISTENCE_PATH", "~/.ipfs_kit/mcp_debug")


# Import proxy backends for storage simulation
# These imports will add simulation endpoints for storage backends
# Note: We'll add these endpoints directly to the FastAPI app

def create_app():
    """Create and configure the FastAPI app with MCP server."""
    # Create FastAPI app
    app = FastAPI(
        title="IPFS MCP Server",
        description="Model-Controller-Persistence Server for IPFS Kit",
        version="0.1.0"
    )
    
    # Add simulation endpoints for storage backends
    
    # ===== STORAGE BACKEND SIMULATION ENDPOINTS =====
    # These endpoints provide simulation capabilities for storage backends
    
    # HuggingFace Backend Simulation
    @app.get(f"{api_prefix}/huggingface/status")
    async def huggingface_status():
        """Simulation status endpoint for HuggingFace storage backend."""
        return {
            "success": True,
            "operation_id": f"status_{int(time.time() * 1000)}",
            "duration_ms": 1.5,
            "backend_name": "storage_huggingface",
            "is_available": True,
            "capabilities": ["from_ipfs", "to_ipfs"],
            "simulation": True
        }
        
    @app.post(f"{api_prefix}/huggingface/from_ipfs")
    async def huggingface_from_ipfs(request: Request):
        """Simulate transferring content from IPFS to HuggingFace Hub."""
        data = await request.json()
        cid = data.get("cid")
        repo_id = data.get("repo_id", "test-repo")
        
        if not cid:
            return JSONResponse(status_code=422, content={"success": False, "error": "CID required"})
        if not repo_id:
            return JSONResponse(status_code=422, content={"success": False, "error": "repo_id required"})
            
        return {
            "success": True,
            "cid": cid,
            "repo_id": repo_id,
            "path_in_repo": f"ipfs/{cid}",
            "simulation": True,
            "timestamp": time.time()
        }
        
    @app.post(f"{api_prefix}/huggingface/to_ipfs")
    async def huggingface_to_ipfs(request: Request):
        """Simulate retrieving content from HuggingFace Hub to IPFS."""
        data = await request.json()
        repo_id = data.get("repo_id")
        path_in_repo = data.get("path_in_repo")
        
        if not repo_id:
            return JSONResponse(status_code=422, content={"success": False, "error": "repo_id required"})
        if not path_in_repo:
            return JSONResponse(status_code=422, content={"success": False, "error": "path_in_repo required"})
            
        # Generate a deterministic CID based on input parameters
        import hashlib
        hash_input = f"{repo_id}:{path_in_repo}".encode()
        hash_hex = hashlib.sha256(hash_input).hexdigest()
        simulated_cid = f"bafyrei{hash_hex[:38]}"
            
        return {
            "success": True,
            "cid": simulated_cid,
            "repo_id": repo_id,
            "path_in_repo": path_in_repo,
            "simulation": True,
            "timestamp": time.time()
        }
        
    # Storacha Backend Simulation
    @app.get(f"{api_prefix}/storacha/status")
    async def storacha_status():
        """Simulation status endpoint for Storacha storage backend."""
        return {
            "success": True,
            "operation_id": f"status_{int(time.time() * 1000)}",
            "duration_ms": 1.8,
            "backend_name": "storage_storacha",
            "is_available": True,
            "capabilities": ["from_ipfs", "to_ipfs"],
            "simulation": True
        }
        
    @app.post(f"{api_prefix}/storacha/from_ipfs")
    async def storacha_from_ipfs(request: Request):
        """Simulate transferring content from IPFS to Storacha."""
        data = await request.json()
        cid = data.get("cid")
        
        if not cid:
            return JSONResponse(status_code=422, content={"success": False, "error": "CID required"})
            
        # Generate a deterministic CAR CID
        car_cid = f"bafy{cid[5:15]}car{cid[15:25]}"
            
        return {
            "success": True,
            "cid": cid,
            "car_cid": car_cid,
            "space_did": "did:key:z6MkqknydjnZk6Hn8yQSxpnHmgLMPdFMvNgWKbFXVqQ89fK7",
            "simulation": True,
            "timestamp": time.time()
        }
        
    @app.post(f"{api_prefix}/storacha/to_ipfs")
    async def storacha_to_ipfs(request: Request):
        """Simulate retrieving content from Storacha to IPFS."""
        data = await request.json()
        car_cid = data.get("car_cid")
        cid = data.get("cid")
        
        if not car_cid and not cid:
            return JSONResponse(status_code=422, content={"success": False, "error": "Either car_cid or cid required"})
            
        # Use provided CID or generate one from CAR CID
        return_cid = cid if cid else f"bafyrei{car_cid[10:48]}"
            
        return {
            "success": True,
            "cid": return_cid,
            "car_cid": car_cid,
            "simulation": True,
            "timestamp": time.time()
        }
        
    # Filecoin Backend Simulation
    @app.get(f"{api_prefix}/filecoin/status")
    async def filecoin_status():
        """Simulation status endpoint for Filecoin storage backend."""
        return {
            "success": True,
            "operation_id": f"status_{int(time.time() * 1000)}",
            "duration_ms": 2.1,
            "backend_name": "storage_filecoin",
            "is_available": True,
            "capabilities": ["from_ipfs", "to_ipfs"],
            "simulation": True
        }
        
    @app.post(f"{api_prefix}/filecoin/from_ipfs")
    async def filecoin_from_ipfs(request: Request):
        """Simulate transferring content from IPFS to Filecoin."""
        data = await request.json()
        cid = data.get("cid")
        
        if not cid:
            return JSONResponse(status_code=422, content={"success": False, "error": "CID required"})
            
        # Generate a deterministic deal ID
        import hashlib
        hash_input = f"deal:{cid}".encode()
        hash_hex = hashlib.sha256(hash_input).hexdigest()
        deal_id = f"f0{hash_hex[:8]}"
            
        return {
            "success": True,
            "cid": cid,
            "deal_id": deal_id,
            "simulation": True,
            "timestamp": time.time()
        }
        
    @app.post(f"{api_prefix}/filecoin/to_ipfs")
    async def filecoin_to_ipfs(request: Request):
        """Simulate retrieving content from Filecoin to IPFS."""
        data = await request.json()
        deal_id = data.get("deal_id")
        
        if not deal_id:
            return JSONResponse(status_code=422, content={"success": False, "error": "deal_id required"})
            
        # Generate a deterministic CID based on deal ID
        import hashlib
        hash_input = f"retrieve:{deal_id}".encode()
        hash_hex = hashlib.sha256(hash_input).hexdigest()
        simulated_cid = f"bafyrei{hash_hex[:38]}"
            
        return {
            "success": True,
            "cid": simulated_cid,
            "deal_id": deal_id,
            "simulation": True,
            "timestamp": time.time()
        }
        
    # Lassie Backend Simulation
    @app.get(f"{api_prefix}/lassie/status")
    async def lassie_status():
        """Simulation status endpoint for Lassie retrieval backend."""
        return {
            "success": True,
            "operation_id": f"status_{int(time.time() * 1000)}",
            "duration_ms": 1.2,
            "backend_name": "storage_lassie",
            "is_available": True,
            "capabilities": ["to_ipfs"],
            "simulation": True
        }
        
    @app.post(f"{api_prefix}/lassie/to_ipfs")
    async def lassie_to_ipfs(request: Request):
        """Simulate retrieving content using Lassie."""
        data = await request.json()
        cid = data.get("cid")
        
        if not cid:
            return JSONResponse(status_code=422, content={"success": False, "error": "CID required"})
            
        return {
            "success": True,
            "cid": cid,
            "size_bytes": 1048576,  # Simulate 1MB file
            "simulation": True,
            "timestamp": time.time()
        }
        
    # S3 Backend Simulation
    @app.get(f"{api_prefix}/s3/status")
    async def s3_status():
        """Simulation status endpoint for S3 storage backend."""
        return {
            "success": True,
            "operation_id": f"status_{int(time.time() * 1000)}",
            "duration_ms": 1.4,
            "backend_name": "s3",
            "is_available": True,
            "capabilities": ["from_ipfs", "to_ipfs"],
            "simulation": True
        }
        
    @app.post(f"{api_prefix}/s3/from_ipfs")
    async def s3_from_ipfs(request: Request):
        """Simulate transferring content from IPFS to S3."""
        data = await request.json()
        cid = data.get("cid")
        bucket = data.get("bucket")
        key = data.get("key", f"ipfs/{cid}")
        
        if not cid:
            return JSONResponse(status_code=422, content={"success": False, "error": "CID required"})
        if not bucket:
            return JSONResponse(status_code=422, content={"success": False, "error": "bucket required"})
            
        return {
            "success": True,
            "cid": cid,
            "bucket": bucket,
            "key": key,
            "simulation": True,
            "timestamp": time.time()
        }
        
    @app.post(f"{api_prefix}/s3/to_ipfs")
    async def s3_to_ipfs(request: Request):
        """Simulate retrieving content from S3 to IPFS."""
        data = await request.json()
        bucket = data.get("bucket")
        key = data.get("key")
        
        if not bucket:
            return JSONResponse(status_code=422, content={"success": False, "error": "bucket required"})
        if not key:
            return JSONResponse(status_code=422, content={"success": False, "error": "key required"})
            
        # Generate a deterministic CID based on bucket and key
        import hashlib
        hash_input = f"{bucket}:{key}".encode()
        hash_hex = hashlib.sha256(hash_input).hexdigest()
        simulated_cid = f"bafyrei{hash_hex[:38]}"
            
        return {
            "success": True,
            "cid": simulated_cid,
            "bucket": bucket,
            "key": key,
            "simulation": True,
            "timestamp": time.time()
        }
    
    # Add a custom pins endpoint that always works
    @app.get(f"{api_prefix}/mcp/cli/pins")
    async def list_pins():
        """Simple pins endpoint that always returns an empty list."""
        return {
            "success": True,
            "result": {
                "pins": {}
            },
            "operation_id": None,
            "format": None
        }
    
    # Import MCP server
    try:
        from ipfs_kit_py.mcp.server import MCPServer
        
        # Create MCP server
        mcp_server = MCPServer(
            debug_mode=debug_mode,
            isolation_mode=isolation_mode,
            persistence_path=os.path.expanduser(persistence_path)
        )
        
        # Register with app
        mcp_server.register_with_app(app, prefix=api_prefix)
        
        # Add root endpoint
        @app.get("/")
        async def root():
            """Root endpoint with API information."""
            # Get daemon status
            daemon_info = {}
            if hasattr(mcp_server.ipfs_kit, 'check_daemon_status'):
                try:
                    daemon_status = mcp_server.ipfs_kit.check_daemon_status()
                    for daemon_name, status in daemon_status.get("daemons", {}).items():
                        daemon_info[daemon_name] = {
                            "running": status.get("running", False),
                            "pid": status.get("pid")
                        }
                except Exception as e:
                    daemon_info["error"] = str(e)
                    
            # Available controllers
            controllers = list(mcp_server.controllers.keys())
            
            # Example endpoints
            example_endpoints = {
                "ipfs": {
                    "version": f"{api_prefix}/ipfs/version",
                    "add": f"{api_prefix}/ipfs/add",
                    "cat": f"{api_prefix}/ipfs/cat/{{cid}}",
                    "pin": f"{api_prefix}/ipfs/pin/add"
                },
                "daemon": {
                    "status": f"{api_prefix}/daemon/status"
                },
                "health": f"{api_prefix}/health"
            }
            
            # Help message about URL structure
            help_message = f"""
            The MCP server exposes endpoints under the {api_prefix} prefix.
            Controller endpoints use the pattern: {api_prefix}/{{controller}}/{{operation}}
            Examples:
            - IPFS Version: {api_prefix}/ipfs/version
            - Health Check: {api_prefix}/health
            """
            
            return {
                "message": "MCP Server is running",
                "debug_mode": debug_mode,
                "isolation_mode": isolation_mode,
                "daemon_status": daemon_info,
                "controllers": controllers,
                "example_endpoints": example_endpoints,
                "help": help_message,
                "documentation": "/docs"
            }
        
        return app, mcp_server
        
    except Exception as e:
        logger.error(f"Failed to initialize MCP server: {e}")
        app = FastAPI()
        
        @app.get("/")
        async def error():
            return {"error": f"Failed to initialize MCP server: {str(e)}"}
            
        return app, None

# Create the app for uvicorn
app, mcp_server = create_app()

if __name__ == "__main__":
    # Run uvicorn directly
    logger.info(f"Starting MCP server on port 9991 with API prefix: {api_prefix}")
    logger.info(f"Debug mode: {debug_mode}, Isolation mode: {isolation_mode}")
    logger.info(f"Storage backends enabled in simulation mode")
    
    uvicorn.run(
        "run_mcp_server_with_storage:app", 
        host="0.0.0.0", 
        port=9991,
        reload=False,  # Disable reload to avoid duplicate process issues
        log_level="info"
    )