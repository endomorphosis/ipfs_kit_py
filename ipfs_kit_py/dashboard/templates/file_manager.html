<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPFS MFS File Manager</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f4f4f4;
        }
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            margin: auto;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        .path-display {
            font-size: 16px;
            color: #555;
            margin-bottom: 15px;
            word-break: break-all;
        }
        .file-list {
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 300px;
            padding: 10px;
            overflow-y: auto;
            background-color: #f9f9f9;
        }
        .file-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
        }
        .file-item:last-child {
            border-bottom: none;
        }
        .file-item:hover {
            background-color: #e9e9e9;
        }
        .file-item.selected {
            background-color: #d0e0ff;
        }
        .file-icon {
            margin-right: 10px;
            font-size: 18px;
            color: #666;
        }
        .file-name {
            flex-grow: 1;
        }
        .file-size {
            font-size: 12px;
            color: #888;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        .controls button, .controls input[type="text"] {
            padding: 8px 15px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
        }
        .controls button {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
        }
        .controls button:hover {
            background-color: #0056b3;
            border-color: #0056b3;
        }
        .controls input[type="text"] {
            flex-grow: 1;
            min-width: 150px;
        }
        .upload-area {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin-top: 20px;
            color: #888;
            cursor: pointer;
        }
        .upload-area.dragover {
            border-color: #007bff;
            background-color: #e6f2ff;
        }
        .hidden-file-input {
            display: none;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            border-radius: 8px;
            position: relative;
        }
        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .file-content-display {
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 400px;
            overflow-y: auto;
            background-color: #eee;
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>IPFS MFS File Manager</h1>
            <button onclick="goUp()">Up</button>
        </div>
        <div class="path-display">Current Path: <span id="currentPath">/</span></div>
        <div class="file-list" id="fileList">
            <!-- File items will be loaded here -->
        </div>
        <div class="controls">
            <input type="text" id="newFolderName" placeholder="New folder name">
            <button onclick="createFolder()">Create Folder</button>
            <input type="text" id="newFileName" placeholder="New file name">
            <button onclick="createFile()">Create File</button>
            <button onclick="deleteSelected()">Delete Selected</button>
            <button onclick="refreshList()">Refresh</button>
        </div>
        <div class="upload-area" id="uploadArea">
            Drag & Drop files here or click to upload
            <input type="file" id="fileInput" class="hidden-file-input" multiple>
        </div>
    </div>

    <!-- File Content Modal -->
    <div id="fileContentModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <h2>File Content: <span id="modalFileName"></span></h2>
            <pre class="file-content-display" id="fileContent"></pre>
        </div>
    </div>

    <script>
        const API_BASE_URL = window.location.origin; // Assuming API is on the same host/port
        let currentPath = '/';
        let selectedItem = null;

        document.addEventListener('DOMContentLoaded', loadFiles);

        async function loadFiles(path = '/') {
            currentPath = path;
            document.getElementById('currentPath').textContent = path;
            const fileListDiv = document.getElementById('fileList');
            fileListDiv.innerHTML = '';
            selectedItem = null;

            try {
                const response = await fetch(`${API_BASE_URL}/api/v0/mfs/list?path=${encodeURIComponent(path)}`);
                const data = await response.json();

                if (data.success) {
                    data.entries.sort((a, b) => {
                        if (a.type === 'directory' && b.type !== 'directory') return -1;
                        if (a.type !== 'directory' && b.type === 'directory') return 1;
                        return a.name.localeCompare(b.name);
                    });

                    data.entries.forEach(item => {
                        const itemDiv = document.createElement('div');
                        itemDiv.className = 'file-item';
                        itemDiv.dataset.path = item.path;
                        itemDiv.dataset.type = item.type;

                        const icon = item.type === 'directory' ? 'üìÅ' : 'üìÑ';
                        const size = item.type === 'file' ? formatBytes(item.size) : '';

                        itemDiv.innerHTML = `
                            <span class="file-icon">${icon}</span>
                            <span class="file-name">${item.name}</span>
                            <span class="file-size">${size}</span>
                        `;
                        itemDiv.onclick = () => selectItem(itemDiv);
                        itemDiv.ondblclick = () => handleItemDoubleClick(item);
                        fileListDiv.appendChild(itemDiv);
                    });
                } else {
                    alert('Error loading files: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Fetch error:', error);
                alert('Failed to connect to server or load files.');
            }
        }

        function selectItem(itemDiv) {
            if (selectedItem) {
                selectedItem.classList.remove('selected');
            }
            selectedItem = itemDiv;
            selectedItem.classList.add('selected');
        }

        async function handleItemDoubleClick(item) {
            if (item.type === 'directory') {
                loadFiles(item.path);
            } else {
                // Read file content
                try {
                    const response = await fetch(`${API_BASE_URL}/api/v0/mfs/read?path=${encodeURIComponent(item.path)}`);
                    const data = await response.json();

                    if (data.success) {
                        document.getElementById('modalFileName').textContent = item.name;
                        document.getElementById('fileContent').textContent = data.content;
                        document.getElementById('fileContentModal').style.display = 'block';
                    } else {
                        alert('Error reading file: ' + (data.error || 'Unknown error'));
                    }
                } catch (error) {
                    console.error('Fetch error:', error);
                    alert('Failed to read file content.');
                }
            }
        }

        function closeModal() {
            document.getElementById('fileContentModal').style.display = 'none';
        }

        function goUp() {
            const parentPath = currentPath.split('/').slice(0, -1).join('/') || '/';
            loadFiles(parentPath);
        }

        async function createFolder() {
            const folderName = document.getElementById('newFolderName').value.trim();
            if (!folderName) {
                alert('Please enter a folder name.');
                return;
            }
            const newPath = PathUtils.join(currentPath, folderName);

            try {
                const response = await fetch(`${API_BASE_URL}/api/v0/mfs/mkdir`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: newPath, parents: false })
                });
                const data = await response.json();

                if (data.success) {
                    document.getElementById('newFolderName').value = '';
                    loadFiles(currentPath);
                } else {
                    alert('Error creating folder: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Fetch error:', error);
                alert('Failed to create folder.');
            }
        }

        async function createFile() {
            const fileName = document.getElementById('newFileName').value.trim();
            if (!fileName) {
                alert('Please enter a file name.');
                return;
            }
            const newPath = PathUtils.join(currentPath, fileName);

            // For simplicity, create an empty file. In a real app, you'd open an editor.
            try {
                const formData = new FormData();
                formData.append('path', newPath);
                formData.append('file', new Blob([''], { type: 'text/plain' }), fileName); // Empty blob

                const response = await fetch(`${API_BASE_URL}/api/v0/mfs/write?path=${encodeURIComponent(newPath)}`, {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();

                if (data.success) {
                    document.getElementById('newFileName').value = '';
                    loadFiles(currentPath);
                } else {
                    alert('Error creating file: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Fetch error:', error);
                alert('Failed to create file.');
            }
        }

        async function deleteSelected() {
            if (!selectedItem) {
                alert('Please select an item to delete.');
                return;
            }

            const itemPath = selectedItem.dataset.path;
            const itemType = selectedItem.dataset.type;

            if (!confirm(`Are you sure you want to delete ${itemType} "${PathUtils.basename(itemPath)}"?`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/api/v0/mfs/rm`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ path: itemPath, recursive: itemType === 'directory', force: true })
                });
                const data = await response.json();

                if (data.success) {
                    loadFiles(currentPath);
                } else {
                    alert('Error deleting item: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Fetch error:', error);
                alert('Failed to delete item.');
            }
        }

        function refreshList() {
            loadFiles(currentPath);
        }

        // Drag and Drop functionality
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFiles);

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.items) {
                handleDroppedItems(e.dataTransfer.items);
            } else {
                handleFiles(e.dataTransfer.files);
            }
        });

        async function handleDroppedItems(items) {
            for (let i = 0; i < items.length; i++) {
                const item = items[i].webkitGetAsEntry();
                if (item) {
                    await traverseFileTree(item, currentPath);
                }
            }
            loadFiles(currentPath); // Refresh after all uploads
        }

        async function traverseFileTree(item, path) {
            if (item.isFile) {
                await new Promise((resolve) => {
                    item.file(async (file) => {
                        const filePath = PathUtils.join(path, item.name);
                        console.log(`Uploading file: ${filePath}`);
                        try {
                            const formData = new FormData();
                            formData.append('path', filePath);
                            formData.append('file', file, item.name);

                            const response = await fetch(`${API_BASE_URL}/api/v0/mfs/write?path=${encodeURIComponent(filePath)}`, {
                                method: 'POST',
                                body: formData
                            });
                            const data = await response.json();
                            if (!data.success) {
                                console.error(`Error uploading ${filePath}:`, data.error);
                            }
                        } catch (error) {
                            console.error(`Failed to upload ${filePath}:`, error);
                        }
                        resolve();
                    });
                });
            } else if (item.isDirectory) {
                const dirPath = PathUtils.join(path, item.name);
                console.log(`Creating directory: ${dirPath}`);
                try {
                    const response = await fetch(`${API_BASE_URL}/api/v0/mfs/mkdir`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: dirPath, parents: false })
                    });
                    const data = await response.json();
                    if (!data.success) {
                        console.error(`Error creating directory ${dirPath}:`, data.error);
                    }
                } catch (error) {
                    console.error(`Failed to create directory ${dirPath}:`, error);
                }

                const dirReader = item.createReader();
                await new Promise((resolve) => {
                    dirReader.readEntries(async (entries) => {
                        for (const entry of entries) {
                            await traverseFileTree(entry, dirPath);
                        }
                        resolve();
                    });
                });
            }
        }

        async function handleFiles(event) {
            const files = event.target.files;
            if (!files) return;

            for (const file of files) {
                const filePath = PathUtils.join(currentPath, file.name);
                console.log(`Uploading file: ${filePath}`);
                try {
                    const formData = new FormData();
                    formData.append('path', filePath);
                    formData.append('file', file, file.name);

                    const response = await fetch(`${API_BASE_URL}/api/v0/mfs/write?path=${encodeURIComponent(filePath)}`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await response.json();
                    if (!data.success) {
                        console.error(`Error uploading ${filePath}:`, data.error);
                    }
                } catch (error) {
                    console.error(`Failed to upload ${filePath}:`, error);
                }
            }
            loadFiles(currentPath); // Refresh after all uploads
        }

        // Utility functions (from mfs_enhanced.py, adapted for JS)
        const PathUtils = {
            join: (...paths) => {
                const pathSegments = paths.filter(p => p);
                let result = pathSegments.join('/');
                if (!result.startsWith('/')) {
                    result = '/' + result;
                }
                return result.replace(/\/\/+/g, '/'); // Normalize multiple slashes
            },
            basename: (path) => {
                if (path === '/' || !path) {
                    return '';
                }
                path = path.endsWith('/') ? path.slice(0, -1) : path;
                return path.substring(path.lastIndexOf('/') + 1);
            }
        };

        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
