name: Auto-Heal Workflow

# This workflow automatically creates pull requests to fix failed workflows and CLI errors
on:
  issues:
    types: [labeled, opened]

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  create-fix-pr:
    name: Create Auto-Healing PR
    runs-on: ubuntu-latest
    # Run if the issue has the auto-heal label and either workflow-failure or cli-error
    if: |
      contains(github.event.issue.labels.*.name, 'auto-heal') &&
      (contains(github.event.issue.labels.*.name, 'workflow-failure') ||
       contains(github.event.issue.labels.*.name, 'cli-error'))
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install PyGithub requests pyyaml
    
    - name: Parse issue details
      id: parse
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueBody = context.payload.issue.body;
          const runIdMatch = issueBody.match(/\*\*Run ID:\*\* (\d+)/);
          const workflowMatch = issueBody.match(/\*\*Workflow:\*\* (.+)/);
          const branchMatch = issueBody.match(/\*\*Branch:\*\* (.+)/);
          const commitMatch = issueBody.match(/\*\*Commit:\*\* (.+)/);
          
          if (runIdMatch) {
            core.setOutput('run_id', runIdMatch[1]);
          }
          if (workflowMatch) {
            core.setOutput('workflow_name', workflowMatch[1].trim());
          }
          if (branchMatch) {
            core.setOutput('branch', branchMatch[1].trim());
          }
          if (commitMatch) {
            core.setOutput('commit', commitMatch[1].trim());
          }
          
          core.setOutput('issue_number', context.payload.issue.number);
          
          // Detect if this is a CLI error or workflow failure
          const labels = context.payload.issue.labels.map(l => l.name);
          const isCliError = labels.includes('cli-error');
          const isWorkflowFailure = labels.includes('workflow-failure');
          
          core.setOutput('is_cli_error', isCliError.toString());
          core.setOutput('is_workflow_failure', isWorkflowFailure.toString());
    
    - name: Generate fix analysis
      id: generate_fix
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        WORKFLOW_RUN_ID: ${{ steps.parse.outputs.run_id }}
        WORKFLOW_NAME: ${{ steps.parse.outputs.workflow_name }}
        ISSUE_NUMBER: ${{ steps.parse.outputs.issue_number }}
        REPOSITORY: ${{ github.repository }}
        IS_CLI_ERROR: ${{ steps.parse.outputs.is_cli_error }}
        IS_WORKFLOW_FAILURE: ${{ steps.parse.outputs.is_workflow_failure }}
      run: |
        if [ "$IS_CLI_ERROR" = "true" ]; then
          echo "Generating fix for CLI error..."
          python scripts/ci/generate_cli_error_fix.py
          # Copy output for consistency
          if [ -f /tmp/cli_error_fix.json ]; then
            cp /tmp/cli_error_fix.json /tmp/workflow_fix.json
          fi
        elif [ "$IS_WORKFLOW_FAILURE" = "true" ]; then
          echo "Generating fix for workflow failure..."
          python scripts/ci/generate_workflow_fix.py
        else
          echo "Unknown issue type, defaulting to workflow fix..."
          python scripts/ci/generate_workflow_fix.py
        fi
    
    - name: Create fix branch and PR
      if: steps.generate_fix.outputs.has_fix == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const { execSync } = require('child_process');
          
          const issueNumber = '${{ steps.parse.outputs.issue_number }}';
          const workflowName = '${{ steps.parse.outputs.workflow_name }}'.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase();
          const branchName = `auto-heal/workflow-${workflowName}-${Date.now()}`;
          
          // Configure git
          execSync('git config user.name "GitHub Actions Bot"');
          execSync('git config user.email "actions@github.com"');
          
          // Create and checkout new branch
          execSync(`git checkout -b ${branchName}`);
          
          // Read the fix details
          const fixFile = '/tmp/workflow_fix.json';
          let fix = {};
          if (fs.existsSync(fixFile)) {
            fix = JSON.parse(fs.readFileSync(fixFile, 'utf8'));
          }
          
          // Apply the fixes if there are file changes
          if (fix.files && fix.files.length > 0) {
            fix.files.forEach(file => {
              if (file.content) {
                fs.writeFileSync(file.path, file.content);
                execSync(`git add ${file.path}`);
              }
            });
            
            execSync(`git commit -m "Auto-heal: Fix workflow ${workflowName} (Issue #${issueNumber})"`);
            execSync(`git push origin ${branchName}`);
          }
          
          // Create the pull request
          const prTitle = `[Auto-Heal] Fix workflow: ${fix.workflow_name || workflowName}`;
          const prBody = `## Auto-Generated Workflow Fix
          
          This PR was automatically generated to fix the failed workflow: **${fix.workflow_name || workflowName}**
          
          ### Issue
          Fixes #${issueNumber}
          
          ### Analysis
          ${fix.analysis || 'No detailed analysis available'}
          
          ### Changes Made
          ${fix.changes ? fix.changes.map(change => `- ${change}`).join('\n') : 'No specific changes listed'}
          
          ### Failure Details
          **Run ID:** ${{ steps.parse.outputs.run_id }}
          **Original Branch:** ${{ steps.parse.outputs.branch }}
          **Commit:** ${{ steps.parse.outputs.commit }}
          
          ### Error Summary
          \`\`\`
          ${fix.error_summary || 'No error summary available'}
          \`\`\`
          
          ### Suggested Fix
          ${fix.suggested_fix || 'See code changes in this PR'}
          
          ### Testing
          ${fix.testing_notes || 'Please test this fix by running the workflow manually or merging to test the auto-heal system.'}
          
          ---
          
          ü§ñ **Note:** This PR should automatically trigger GitHub Copilot agent to review and potentially enhance the fix.
          
          If this fix does not resolve the issue, please:
          1. Comment on this PR with additional context
          2. The auto-heal system will learn from the feedback
          3. Manually adjust the fix if needed
          
          ---
          *This PR was automatically created by the Auto-Healing Workflow system*
          `;
          
          try {
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: prTitle,
              body: prBody,
              head: branchName,
              base: 'main'
            });
            
            console.log(`Created PR #${pr.data.number}`);
            
            // Add labels to the PR
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.data.number,
              labels: ['auto-heal', 'workflow-fix', 'automated-pr']
            });
            
            // Comment on the original issue
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `ü§ñ Auto-healing PR created: #${pr.data.number}\n\nThe system has generated a potential fix for this error. Please review the PR.`
            });
            
            // If no changes were made, invoke GitHub Copilot
            if (!fix.files || fix.files.length === 0) {
              // Label for GitHub Copilot to pick up
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                labels: ['copilot-assist-needed']
              });
              
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                body: `‚ö†Ô∏è The auto-healing system could not generate an automatic fix.\n\n**Reason:** ${fix.reason || 'Unable to determine root cause automatically'}\n\nü§ñ **GitHub Copilot has been invoked** to analyze this error and provide an AI-assisted fix.\n\nPlease wait for the Copilot agent to respond with a suggested solution.`
              });
            }
          } catch (error) {
            console.error('Error creating PR:', error);
            
            // Comment on the issue about the failure
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `‚ùå Failed to create auto-healing PR: ${error.message}\n\nPlease review the workflow failure manually.`
            });
          }
    
    - name: Update issue status
      if: always()
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const issueNumber = '${{ steps.parse.outputs.issue_number }}';
          
          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: issueNumber,
            body: '‚úÖ Auto-healing process completed. Check above for PR details or manual intervention notes.'
          });
