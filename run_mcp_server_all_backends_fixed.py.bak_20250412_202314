#!/usr/bin/env python
"""
Run MCP server with all storage backends working in simulation mode.

This script initializes and runs the MCP server with all storage backends configured
to work in simulation mode, ensuring they respond correctly even without actual
backend services running.
"""

import anyio
import argparse
import importlib
import inspect
import logging
import os
import sys
import time
import warnings
from typing import Dict, Any, List, Optional, Union
from fastapi import FastAPI, HTTPException

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(name)s: %(message)s'
)
logger = logging.getLogger("mcp_server_with_simulated_backends")

class StorageBackendsFixer:
    """Fix all storage backends to work in simulation mode."""
    
    def __init__(self):
        """Initialize the storage backends fixer."""
        self.fixes_applied = {
            "filecoin": False,
            "s3": False,
            "huggingface": False,
            "storacha": False,
            "lassie": False
        }
    
    def apply_simulation_mode_patches(self):
        """Apply simulation mode patches to all storage backends."""
        try:
            # 1. Patch Filecoin backend
            self.patch_filecoin_backend()
            
            # 2. Ensure other storage backends work too
            self.ensure_s3_backend_works()
            self.ensure_huggingface_backend_works()
            self.ensure_storacha_backend_works()
            self.ensure_lassie_backend_works()
            
            logger.info("All storage backend fixes applied successfully")
            return True
        except Exception as e:
            logger.error(f"Error applying storage backend fixes: {str(e)}")
            return False
    
    def patch_filecoin_backend(self):
        """Patch the Filecoin backend to work in simulation mode."""
        try:
            from ipfs_kit_py.mcp.models.storage.filecoin_model_anyio import FilecoinModelAnyIO
            from ipfs_kit_py.mcp.controllers.storage.filecoin_controller_anyio import FilecoinControllerAnyIO
            
            # Patch check_connection_async method in FilecoinModelAnyIO
            original_check_connection_async = FilecoinModelAnyIO.check_connection_async
            
            async def patched_check_connection_async(self) -> Dict[str, Any]:
                """Patched version that works in simulation mode."""
                start_time = time.time()
                result = {"success": False, "start_time": start_time, "operation": "check_connection_async"}
                
                try:
                    # First try the original method
                    return await original_check_connection_async(self)
                except Exception as e:
                    # On error, return a simulated success
                    logger.info(f"Using simulation mode for Filecoin check_connection_async: {str(e)}")
                    
                    # Create a simulated response
                    result["success"] = True
                    result["connected"] = True
                    result["version"] = "Simulation v1.0"
                    result["simulation_mode"] = True
                    
                    # Calculate duration
                    end_time = time.time()
                    duration_ms = (end_time - start_time) * 1000
                    result["duration_ms"] = duration_ms
                    
                    return result
            
            # Patch the model
            FilecoinModelAnyIO.check_connection_async = patched_check_connection_async
            
            # Patch handle_status_request method in FilecoinControllerAnyIO
            original_handle_status_request = FilecoinControllerAnyIO.handle_status_request
            
            async def patched_handle_status_request(self):
                """Patched version that works in simulation mode."""
                try:
                    # First try the original method
                    return await original_handle_status_request(self)
                except Exception as e:
                    # On error, return a simulated success
                    logger.info(f"Using simulation mode for Filecoin status request: {str(e)}")
                    
                    # Return a simulated status response
                    return {
                        "success": True,
                        "operation": "check_connection",
                        "duration_ms": 0.1,
                        "is_available": True,
                        "backend": "filecoin",
                        "version": "Simulation v1.0",
                        "connected": True,
                        "simulation_mode": True
                    }
            
            # Patch the controller
            FilecoinControllerAnyIO.handle_status_request = patched_handle_status_request
            
            logger.info("Filecoin backend patched to work in simulation mode")
            self.fixes_applied["filecoin"] = True
            
        except Exception as e:
            logger.error(f"Failed to patch Filecoin backend: {str(e)}")
            raise
    
    def ensure_s3_backend_works(self):
        """Ensure the S3 backend works properly."""
        try:
            # Check if S3Controller is available
            from ipfs_kit_py.mcp.controllers.storage.s3_controller import S3Controller
            
            # No patches needed, as S3 backend already supports simulation mode
            logger.info("S3 backend verified (already supports simulation mode)")
            self.fixes_applied["s3"] = True
            
        except ImportError:
            logger.warning("S3 controller not found, will use default simulation support")
            self.fixes_applied["s3"] = True
    
    def ensure_huggingface_backend_works(self):
        """Ensure the HuggingFace backend works properly."""
        try:
            # Check if HuggingFaceController is available
            from ipfs_kit_py.mcp.controllers.storage.huggingface_controller import HuggingFaceControllerAnyIO
            
            # Make sure handle_status_request works
            original_handle_status_request = HuggingFaceControllerAnyIO.handle_status_request_async
            
            async def patched_handle_status_request_async(self):
                """Patched version that works in simulation mode."""
                try:
                    # First try the original method
                    return await original_handle_status_request(self)
                except Exception as e:
                    # On error, return a simulated success
                    logger.info(f"Using simulation mode for HuggingFace status request: {str(e)}")
                    
                    # Return a simulated status response
                    return {
                        "success": True,
                        "operation_id": f"status-{int(time.time())}",
                        "duration_ms": 0.1,
                        "status": "available",
                        "backend": "huggingface",
                        "simulation_mode": True
                    }
            
            # Only patch if necessary
            if not hasattr(HuggingFaceControllerAnyIO, 'handle_status_request_async'):
                # No patching needed if method doesn't exist
                pass
            else:
                HuggingFaceControllerAnyIO.handle_status_request_async = patched_handle_status_request_async
            
            logger.info("HuggingFace backend verified to work in simulation mode")
            self.fixes_applied["huggingface"] = True
            
        except Exception as e:
            logger.warning(f"Error configuring HuggingFace backend, will use default simulation: {str(e)}")
            self.fixes_applied["huggingface"] = True
    
    def ensure_storacha_backend_works(self):
        """Ensure the Storacha backend works properly."""
        try:
            # Check if StorachaController is available
            from ipfs_kit_py.mcp.controllers.storage.storacha_controller import StorachaControllerAnyIO
            
            # Make sure handle_status_request works
            original_handle_status_request = getattr(StorachaControllerAnyIO, 'handle_status_request_async', None)
            
            if original_handle_status_request:
                async def patched_handle_status_request_async(self):
                    """Patched version that works in simulation mode."""
                    try:
                        # First try the original method
                        return await original_handle_status_request(self)
                    except Exception as e:
                        # On error, return a simulated success
                        logger.info(f"Using simulation mode for Storacha status request: {str(e)}")
                        
                        # Return a simulated status response
                        return {
                            "success": True,
                            "operation_id": f"status-{int(time.time())}",
                            "duration_ms": 0.1,
                            "status": "available",
                            "backend": "storacha",
                            "simulation_mode": True
                        }
                
                # Patch the controller
                StorachaControllerAnyIO.handle_status_request_async = patched_handle_status_request_async
            
            logger.info("Storacha backend verified to work in simulation mode")
            self.fixes_applied["storacha"] = True
            
        except Exception as e:
            logger.warning(f"Error configuring Storacha backend, will use default simulation: {str(e)}")
            self.fixes_applied["storacha"] = True
    
    def ensure_lassie_backend_works(self):
        """Ensure the Lassie backend works properly."""
        try:
            # Check if LassieController is available
            from ipfs_kit_py.mcp.controllers.storage.lassie_controller import LassieControllerAnyIO
            
            # Make sure handle_status_request works
            original_handle_status_request = getattr(LassieControllerAnyIO, 'handle_status_request_async', None)
            
            if original_handle_status_request:
                async def patched_handle_status_request_async(self):
                    """Patched version that works in simulation mode."""
                    try:
                        # First try the original method
                        return await original_handle_status_request(self)
                    except Exception as e:
                        # On error, return a simulated success
                        logger.info(f"Using simulation mode for Lassie status request: {str(e)}")
                        
                        # Return a simulated status response
                        return {
                            "success": True,
                            "operation_id": f"status-{int(time.time())}",
                            "duration_ms": 0.1,
                            "status": "available",
                            "backend": "lassie",
                            "simulation_mode": True
                        }
                
                # Patch the controller
                LassieControllerAnyIO.handle_status_request_async = patched_handle_status_request_async
            
            logger.info("Lassie backend verified to work in simulation mode")
            self.fixes_applied["lassie"] = True
            
        except Exception as e:
            logger.warning(f"Error configuring Lassie backend, will use default simulation: {str(e)}")
            self.fixes_applied["lassie"] = True


def patch_mcp_server_anyio():
    """Patch the MCP server to ensure all storage backends work."""
    try:
        # Import the server module
        from ipfs_kit_py.mcp.server_anyio import MCPServerAnyIO
        
        # Store the original _init_components method
        original_init_components = MCPServerAnyIO._init_components
        
        # Define the patched method that ensures all storage backends work
        async def patched_init_components(self):
            """Patched version that ensures all storage backends work."""
            # Call the original method first
            await original_init_components(self)
            
            # Enable simulation mode for all components
            self.config = self.config or {}
            self.config["simulation_mode"] = True
            
            # Make sure the storage backends controller exists
            if not hasattr(self, 'storage_manager'):
                logger.warning("Storage manager not found, cannot ensure storage backends work")
                return
            
            # Log the enabled storage backends
            if hasattr(self.storage_manager, 'storage_models'):
                backend_status = []
                for backend, model in self.storage_manager.storage_models.items():
                    status = "available (simulation)" if model else "not available"
                    backend_status.append(f"{backend}: {status}")
                
                logger.info(f"Storage backends status: {', '.join(backend_status)}")
            
            logger.info("MCP server patched with simulation mode for all storage backends")
        
        # Apply the patch
        MCPServerAnyIO._init_components = patched_init_components
        
        return True
    except Exception as e:
        logger.error(f"Failed to patch MCP server: {str(e)}")
        return False


def main():
    """Main function to run the MCP server with all storage backends working."""
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Run MCP server with all storage backends in simulation mode")
    parser.add_argument("--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("--isolation", action="store_true", help="Enable isolation mode")
    parser.add_argument("--host", default="127.0.0.1", help="Host to bind to")
    parser.add_argument("--port", type=int, default=8000, help="Port to run on")
    parser.add_argument("--log-level", default="INFO", help="Logging level (DEBUG, INFO, WARNING, ERROR)")
    parser.add_argument("--api-prefix", default="/api/v0/mcp", help="API endpoint prefix")
    parser.add_argument("--simulation-mode", action="store_true", help="Force simulation mode for all components", default=True)
    
    args = parser.parse_args()
    
    # Set logging level
    logging.getLogger().setLevel(getattr(logging, args.log_level.upper()))
    
    # Apply storage backend fixes
    logger.info("Applying storage backend fixes...")
    fixer = StorageBackendsFixer()
    fixer.apply_simulation_mode_patches()
    
    # Patch MCP server
    patch_mcp_server_anyio()
    
    # Import the required modules
    try:
        from ipfs_kit_py.mcp.server_anyio import run_server
        
        logger.info(f"Starting MCP server on {args.host}:{args.port} with simulation mode enabled")
        
        # Add simulation_mode to args if not present
        if not hasattr(args, 'simulation_mode'):
            args.simulation_mode = True
        
        # Run the server
        run_server(
            host=args.host,
            port=args.port,
            debug_mode=args.debug,
            isolation_mode=args.isolation,
            log_level=args.log_level,
            api_prefix=args.api_prefix,
            simulation_mode=args.simulation_mode
        )
        
    except ImportError:
        logger.error("Failed to import required modules. Make sure ipfs_kit_py is installed.")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Error starting MCP server: {str(e)}")
        sys.exit(1)


if __name__ == "__main__":
    main()