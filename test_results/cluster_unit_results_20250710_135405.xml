<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="3" skipped="0" tests="49" time="1.025" timestamp="2025-07-10T13:54:05.593732-07:00" hostname="barberb-HP-ZBook-Fury-16-G9-Mobile-Workstation-PC"><testcase classname="tests.test_cluster_services.TestNodeRole" name="test_role_values" time="0.002" /><testcase classname="tests.test_cluster_services.TestNodeRole" name="test_role_priorities" time="0.001" /><testcase classname="tests.test_cluster_services.TestPeerInfo" name="test_peer_info_creation" time="0.001" /><testcase classname="tests.test_cluster_services.TestPeerInfo" name="test_peer_info_to_dict" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_master_node_election" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_worker_node_election_without_masters" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_leecher_cannot_be_leader" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_role_hierarchy_priority" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_deterministic_election" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_unhealthy_peer_exclusion" time="0.001" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_heartbeat_monitoring" time="0.000" /><testcase classname="tests.test_cluster_services.TestLeaderElection" name="test_leader_health_check" time="0.000" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_master_can_initiate_replication" time="0.000" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_worker_cannot_initiate_replication" time="0.001" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_leecher_cannot_initiate_replication" time="0.001" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_master_and_worker_can_receive_replication" time="0.002" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_leecher_cannot_receive_replication" time="0.001" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_replication_from_master" time="0.202" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_replication_from_non_master_fails" time="0.001" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_replication_filters_invalid_targets" time="0.201" /><testcase classname="tests.test_cluster_services.TestReplicationManager" name="test_replication_status_tracking" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_master_can_modify_index" time="0.000" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_non_master_cannot_modify_index" time="0.000" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_all_nodes_can_read_index" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_add_index_data_master" time="0.004" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_add_index_data_non_master_fails" time="0.002" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_remove_index_data_master" time="0.002" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_remove_nonexistent_data" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_get_index_data_single_key" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_get_index_data_all_keys" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_invalid_index_type" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_embedding_search" time="0.002" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_index_statistics" time="0.001" /><testcase classname="tests.test_cluster_services.TestIndexingService" name="test_thread_safety" time="0.006" /><testcase classname="tests.test_cluster_services.TestEnhancedDaemonManager" name="test_manager_initialization" time="0.001" /><testcase classname="tests.test_cluster_services.TestEnhancedDaemonManager" name="test_add_peer" time="0.001" /><testcase classname="tests.test_cluster_services.TestEnhancedDaemonManager" name="test_remove_peer" time="0.001" /><testcase classname="tests.test_cluster_services.TestEnhancedDaemonManager" name="test_cluster_status" time="0.003"><failure message="AttributeError: 'EnhancedDaemonManager' object has no attribute 'daemon_type'">self = &lt;tests.test_cluster_services.TestEnhancedDaemonManager object at 0x74e9d144e480&gt;

    def test_cluster_status(self):
        """Test getting cluster status"""
        # Add some test peers
        peer1 = PeerInfo("peer-1", NodeRole.WORKER, "127.0.0.1", 10000)
        peer2 = PeerInfo("peer-2", NodeRole.LEECHER, "127.0.0.1", 10001)
    
        self.manager.add_peer(peer1)
        self.manager.add_peer(peer2)
    
&gt;       status = self.manager.get_cluster_status()

tests/test_cluster_services.py:575: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
enhanced_daemon_manager_with_cluster.py:736: in get_cluster_status
    "daemon_status": self.get_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;enhanced_daemon_manager_with_cluster.EnhancedDaemonManager object at 0x74e9d14ae000&gt;

    def get_status(self) -&gt; Dict[str, Any]:
        """Get daemon status information."""
        status = {
&gt;           "daemon_type": self.daemon_type,
            "running": self.is_running(),
            "initialized": self.is_initialized(),
            "config_dir": self.config_dir,
            "api_port": self.api_port
        }
E       AttributeError: 'EnhancedDaemonManager' object has no attribute 'daemon_type'

scripts/daemon/daemon_manager.py:556: AttributeError</failure></testcase><testcase classname="tests.test_cluster_services.TestEnhancedDaemonManager" name="test_start_mcp_server" time="0.002"><failure message="AttributeError: module 'enhanced_daemon_manager_with_cluster' has no attribute 'subprocess'">args = (&lt;tests.test_cluster_services.TestEnhancedDaemonManager object at 0x74e9d14812b0&gt;,)
keywargs = {}

    @wraps(func)
    def patched(*args, **keywargs):
&gt;       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

/usr/lib/python3.12/unittest/mock.py:1387: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/usr/lib/python3.12/contextlib.py:137: in __enter__
    return next(self.gen)
/usr/lib/python3.12/unittest/mock.py:1369: in decoration_helper
    arg = exit_stack.enter_context(patching)
/usr/lib/python3.12/contextlib.py:526: in enter_context
    result = _enter(cm)
/usr/lib/python3.12/unittest/mock.py:1442: in __enter__
    self.target = self.getter()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

name = 'enhanced_daemon_manager_with_cluster.subprocess'

    def resolve_name(name):
        """
        Resolve a name to an object.
    
        It is expected that `name` will be a string in one of the following
        formats, where W is shorthand for a valid Python identifier and dot stands
        for a literal period in these pseudo-regexes:
    
        W(.W)*
        W(.W)*:(W(.W)*)?
    
        The first form is intended for backward compatibility only. It assumes that
        some part of the dotted name is a package, and the rest is an object
        somewhere within that package, possibly nested inside other objects.
        Because the place where the package stops and the object hierarchy starts
        can't be inferred by inspection, repeated attempts to import must be done
        with this form.
    
        In the second form, the caller makes the division point clear through the
        provision of a single colon: the dotted name to the left of the colon is a
        package to be imported, and the dotted name to the right is the object
        hierarchy within that package. Only one import is needed in this form. If
        it ends with the colon, then a module object is returned.
    
        The function will return an object (which might be a module), or raise one
        of the following exceptions:
    
        ValueError - if `name` isn't in a recognised format
        ImportError - if an import failed when it shouldn't have
        AttributeError - if a failure occurred when traversing the object hierarchy
                         within the imported package to get to the desired object.
        """
        global _NAME_PATTERN
        if _NAME_PATTERN is None:
            # Lazy import to speedup Python startup time
            import re
            dotted_words = r'(?!\d)(\w+)(\.(?!\d)(\w+))*'
            _NAME_PATTERN = re.compile(f'^(?P&lt;pkg&gt;{dotted_words})'
                                       f'(?P&lt;cln&gt;:(?P&lt;obj&gt;{dotted_words})?)?$',
                                       re.UNICODE)
    
        m = _NAME_PATTERN.match(name)
        if not m:
            raise ValueError(f'invalid format: {name!r}')
        gd = m.groupdict()
        if gd.get('cln'):
            # there is a colon - a one-step import is all that's needed
            mod = importlib.import_module(gd['pkg'])
            parts = gd.get('obj')
            parts = parts.split('.') if parts else []
        else:
            # no colon - have to iterate to find the package boundary
            parts = name.split('.')
            modname = parts.pop(0)
            # first part *must* be a module/package.
            mod = importlib.import_module(modname)
            while parts:
                p = parts[0]
                s = f'{modname}.{p}'
                try:
                    mod = importlib.import_module(s)
                    parts.pop(0)
                    modname = s
                except ImportError:
                    break
        # if we reach this point, mod is the module, already imported, and
        # parts is the list of parts in the object hierarchy to be traversed, or
        # an empty list if just the module is wanted.
        result = mod
        for p in parts:
&gt;           result = getattr(result, p)
E           AttributeError: module 'enhanced_daemon_manager_with_cluster' has no attribute 'subprocess'

/usr/lib/python3.12/pkgutil.py:528: AttributeError</failure></testcase><testcase classname="tests.test_cluster_services.TestEnhancedDaemonManager" name="test_health_monitoring_setup" time="0.003" /><testcase classname="tests.test_cluster_services.TestConcurrencyAndPerformance" name="test_concurrent_replication_operations" time="0.102" /><testcase classname="tests.test_cluster_services.TestConcurrencyAndPerformance" name="test_concurrent_indexing_operations" time="0.001" /><testcase classname="tests.test_cluster_services.TestConcurrencyAndPerformance" name="test_leader_election_performance" time="0.001" /><testcase classname="tests.test_cluster_services.TestErrorHandling" name="test_replication_with_no_eligible_peers" time="0.001" /><testcase classname="tests.test_cluster_services.TestErrorHandling" name="test_indexing_with_invalid_permissions" time="0.001" /><testcase classname="tests.test_cluster_services.TestErrorHandling" name="test_leader_election_with_empty_peer_set" time="0.001" /><testcase classname="tests.test_cluster_services.TestErrorHandling" name="test_leader_election_with_all_unhealthy_peers" time="0.002" /><testcase classname="tests.test_cluster_services.TestIntegrationScenarios" name="test_cluster_bootstrap" time="0.002" /><testcase classname="tests.test_cluster_services.TestIntegrationScenarios" name="test_full_cluster_workflow" time="0.104"><failure message="AttributeError: 'EnhancedDaemonManager' object has no attribute 'daemon_type'">self = &lt;tests.test_cluster_services.TestIntegrationScenarios object at 0x74e9d1481d30&gt;
cluster_setup = {'leecher-1': &lt;enhanced_daemon_manager_with_cluster.EnhancedDaemonManager object at 0x74e9d132d880&gt;, 'master-1': &lt;enha... at 0x74e9d12c1550&gt;, 'worker-1': &lt;enhanced_daemon_manager_with_cluster.EnhancedDaemonManager object at 0x74e9d132c8f0&gt;}

    @pytest.mark.asyncio
    async def test_full_cluster_workflow(self, cluster_setup):
        """Test a complete cluster workflow"""
        managers = cluster_setup
        master_manager = managers["master-1"]
    
        # 1. Leader election
        leader = master_manager.leader_election.elect_leader()
        assert leader.role == NodeRole.MASTER
    
        # 2. Add data to index (master only)
        result = await master_manager.indexing_service.add_index_data(
            "embeddings",
            "workflow-doc",
            {"vector": [1.0, 2.0, 3.0], "content": "workflow test"}
        )
        assert result["success"] is True
    
        # 3. Replicate content (master only)
        target_peers = [peer for peer in master_manager.peers.values()
                       if peer.role in [NodeRole.MASTER, NodeRole.WORKER]]
    
        replication_result = await master_manager.replication_manager.replicate_content(
            "QmWorkflowTest",
            target_peers
        )
        assert replication_result["success"] is True
    
        # 4. Check cluster status
&gt;       status = master_manager.get_cluster_status()

tests/test_cluster_services.py:819: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
enhanced_daemon_manager_with_cluster.py:736: in get_cluster_status
    "daemon_status": self.get_status()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;enhanced_daemon_manager_with_cluster.EnhancedDaemonManager object at 0x74e9d12c1550&gt;

    def get_status(self) -&gt; Dict[str, Any]:
        """Get daemon status information."""
        status = {
&gt;           "daemon_type": self.daemon_type,
            "running": self.is_running(),
            "initialized": self.is_initialized(),
            "config_dir": self.config_dir,
            "api_port": self.api_port
        }
E       AttributeError: 'EnhancedDaemonManager' object has no attribute 'daemon_type'

scripts/daemon/daemon_manager.py:556: AttributeError</failure></testcase></testsuite></testsuites>